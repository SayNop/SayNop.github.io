import{_ as t,r as i,o as c,c as o,a as n,b as s,d as l,e as a}from"./app-f8c36182.js";const p="/assets/imgs/018/01.png",d="/assets/imgs/018/02.png",r="/assets/imgs/018/03.png",u={},m=a(`<h2 id="简介" tabindex="-1"><a class="header-anchor" href="#简介" aria-hidden="true">#</a> 简介</h2><ul><li><p>Registries：仓库</p></li><li><p>Docker 对象(Docker Objects)</p><ul><li><p>Image：镜像，docker可执行文件，包括代码、依赖库、环境变量、配置等</p></li><li><p>container：容器，镜像运行的实例</p></li><li><p>network：与宿主机或镜像间的网络通信方式</p><ul><li>bridge：网桥</li><li>host</li><li>none</li><li>overlay</li><li>macvlan</li></ul></li><li><p>volume：数据卷，与宿主机或镜像间的共享存储方式。如：映射到宿主机的文件夹</p></li></ul></li></ul><h3 id="底层技术" tabindex="-1"><a class="header-anchor" href="#底层技术" aria-hidden="true">#</a> 底层技术</h3><blockquote><p>使用Go实现，利用了如下Linux内核的特性（只能在Linux上运行。Win、Mac本质上通过虚拟化，在Linux虚拟机上运行）</p></blockquote><ul><li><p>Namespaces：为容器提供系统层面隔离（与宿主机或容器间的隔离）</p><ul><li>进程隔离：每个容器的进程号都从1开始</li><li>网络隔离</li><li>进程间通信隔离</li><li>文件系统挂载隔离</li><li>内核隔离</li></ul></li><li><p>Control Groups：为容器提供硬件层面隔离：对容器进行约束</p></li><li><p>Union File Systems：镜像和容器的层级存储。当创建或构建一个 Docker 镜像时，Docker 会将每个 <code>RUN</code>、<code>COPY</code>、<code>ADD</code> 等操作都分配为单独的层</p><ul><li><p>示例：一个基础的 Ubuntu 镜像，之后你安装了一个 Python 环境和一个应用</p><div class="language-docker line-numbers-mode" data-ext="docker"><pre class="language-docker"><code><span class="token comment"># 从基础镜像开始</span>
<span class="token instruction"><span class="token keyword">FROM</span> ubuntu:20.04</span>

<span class="token comment"># 更新并安装 Python</span>
<span class="token instruction"><span class="token keyword">RUN</span> apt-get update &amp;&amp; apt-get install -y python3</span>

<span class="token comment"># 将应用程序文件添加到镜像中</span>
<span class="token instruction"><span class="token keyword">COPY</span> myapp.py /app/myapp.py</span>

<span class="token comment"># 设置容器启动时执行的命令</span>
<span class="token instruction"><span class="token keyword">CMD</span> [<span class="token string">&quot;python3&quot;</span>, <span class="token string">&quot;/app/myapp.py&quot;</span>]</span>
</code></pre><div class="line-numbers" aria-hidden="true"><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div></div></div><ul><li>基础Ubuntu镜像：层1</li><li>python：层2</li><li>安装应用：层3</li></ul><p>每一层只记录变更，底层的 Ubuntu 镜像在多个容器之间共享，而每个容器只会记录自己的差异</p></li><li><p>分层的优势</p><ul><li><strong>效率</strong>：通过只保存差异层而不是复制整个文件</li><li><strong>快速启动</strong>：容器能够快速启动，因为它们仅仅是联合的不同层，而不是从头开始复制所有文件</li><li><strong>便于管理</strong>：Docker 镜像的层级结构使得每次镜像的构建都可以只包含差异，而不必重复前面已有的部分</li></ul></li></ul></li></ul><p>容器格式(Contianer Format)：通过将三个特性的内容组合成package。Docker通过控制package的三个特性的内容，实现对容器的创建与管理</p><h2 id="镜像" tabindex="-1"><a class="header-anchor" href="#镜像" aria-hidden="true">#</a> 镜像</h2><ul><li><p>搜索 <code>docker search [OPTIONS] TERM</code></p><p>-f, --filter filter 根据提供的格式筛选结果</p><p>--format string 利用Go语言的format格式化输出结果</p><p>--limit int 展示最大的结果数，默认25个</p><p>--no-trunc 内容全部显示</p><p><strong>E.g.</strong> <code>docker seach -f is-official=true ubuntu</code></p></li><li><p>查看本地 <code>docker images (/ docker image ls) [OPTIONS] [REPOSITORY[:TAG]] </code></p><p>-a, --all 展示所有（默认显示隐藏底层的镜像）</p><p>--no-trunc 不缩略显示</p><p>-q, --quiet 只显示镜像ID</p><p><strong>E.g.</strong> <code>docker images centos:latest</code></p></li><li><p>拉取 <code>docker pull [OPTIONS] NAME[:TAG|@DIGEST]</code></p><p>-a, --all-tags 下载所有符合给定tag的镜像</p></li><li><p>删除 <code>docker rmi (/ docker image rm) [OPTIONS] IMAGE [IMAGE...]</code></p><p>-f, --force 强制删除</p><p><strong>E.g.</strong> 使用ID对镜像进行删除</p><div class="macos language-bash line-numbers-mode" data-ext="sh"><pre class="language-bash"><code><span class="token function">docker</span> images
<span class="token comment"># REPOSITORY		TAG			IMAGE ID			CREATED			SIZE</span>
<span class="token comment"># centos				latest	2zoi3uds09ad	2 days ago	200MB</span>
<span class="token comment"># ubuntu				latest	j89fashd101k	3 days ago	100MB</span>
<span class="token function">docker</span> image <span class="token function">rm</span> 2zoi j89f
</code></pre><div class="line-numbers" aria-hidden="true"><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div></div></div></li><li><p>保存备份 <code>docker save [OPTIONS] IMAGE [IMAGE...]</code> 一个或多个镜像打包</p><p>-o, --output string 指定写入的文件名和路径</p><p><strong>E.g.</strong> <code>docker save -o output.tar centos ubuntu</code></p></li><li><p>导入备份 <code>docker load [OPTIONS]</code></p><p>-i, --input string 指定要打入的文件，如没有指定，默认是STDIN</p><p>-q, --quiet 不打印导入过程信息</p></li><li><p>重命名 <code>docker tag SOURCE_IMAGE[:TAG] TARGET_IMAGE[:TAG]</code> 修改镜像的name与tag信息</p><p><strong>E.g.</strong> <code>docker tag 2zoi customname:customtag</code></p></li><li><p>检视 <code>docker (image) inspect [OPTIONS] IMAGE [IMAGE...]</code> 查看镜像详情</p><p>-f, --format string 利用特定Go语言的format格式输出结果</p><p><strong>E.g.</strong></p><div class="macos language-bash line-numbers-mode" data-ext="sh"><pre class="language-bash"><code><span class="token comment"># 输出信息json</span>
<span class="token function">docker</span> image inspect centos
<span class="token comment"># 输出信息json中Id字段的内容</span>
<span class="token function">docker</span> image inspect <span class="token parameter variable">-f</span> <span class="token string">&quot;{{json .Id}}&quot;</span> centos
<span class="token comment"># 数组信息json中Created的内容</span>
<span class="token function">docker</span> image inspect <span class="token parameter variable">-f</span> <span class="token string">&quot;{{json .Created}}&quot;</span> centos
</code></pre><div class="line-numbers" aria-hidden="true"><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div></div></div></li><li><p>历史（历史分层）信息 <code>docker history [OPTIONS] image</code></p><p>-H, --human 将创建时间、大小进行优化打印(默认为true)</p><p>-q, --quiet 只显示镜像ID</p><p>--no-trunc 缩略显示</p></li></ul><h2 id="容器" tabindex="-1"><a class="header-anchor" href="#容器" aria-hidden="true">#</a> 容器</h2><p>轻量、可移植、将应用打包的技术。镜像运行后，产生的对象就是容器。相当于镜像运行后的实例。</p><p><strong>类比虚拟机</strong></p><ul><li>相同点 <ul><li>共享物理资源</li><li>生命周期类似</li><li>内部可安装应用</li><li>创建完成后物理存储在宿主机上（路径 <em>/var/lib/docker/containers</em> ）</li></ul></li><li>不同点 <ul><li>虚拟机是完整独立的操作系统，容器是运行在宿主内核之上，只从bins/libs开始独立</li><li>比虚拟机更加轻量</li></ul></li></ul><h3 id="生命周期" tabindex="-1"><a class="header-anchor" href="#生命周期" aria-hidden="true">#</a> 生命周期</h3><p><img src="`+p+`" alt="生命周期"></p><h3 id="相关操作" tabindex="-1"><a class="header-anchor" href="#相关操作" aria-hidden="true">#</a> 相关操作</h3><ul><li><p>创建 <code>docker create [OPTIONS] IMAGE [COMMAND] [ARG...]</code> 利用镜像创建出一个Created 状态的待启动容器</p><p>-t, --tty 分配一个伪TTY，也就是分配虚拟终端</p><p>-i, --interactive 即使没有连接，也要保持STDIN打开</p><p>--name 为容器起名，如果没有指定将会随机产生一个名称</p><ul><li><p><code>[COMMAND]</code>: 容器启动后，需要在容器中执行的命令，如ps、ls 等命令</p></li><li><p><code>[ARG...]</code>: 执行 COMMAND 时需要提供的一些参数，如ps 命令的 aux、ls命令的-a等等</p></li></ul><p><strong>E.g.</strong></p><div class="macos language-bash line-numbers-mode" data-ext="sh"><pre class="language-bash"><code><span class="token function">docker</span> create <span class="token parameter variable">--name</span> custom-container centos <span class="token function">ps</span> <span class="token parameter variable">-A</span>
<span class="token comment"># 启动时执行 /bin/bash 常搭配-t使用</span>
<span class="token function">docker</span> create <span class="token parameter variable">-it</span> <span class="token parameter variable">--name</span> custom-container2 centos /bin/bash
</code></pre><div class="line-numbers" aria-hidden="true"><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div></div></div></li><li><p>启动 <code>docker start [OPTIONS] CONTAINER [CONTAINER...]</code> 将创建(created)或关闭(exited)状态的容器启动</p><p>-a, --attach 将当前shell的 STDOUT/STDERR 连接到容器上</p><p>-i, --interactive 将当前shell的 STDIN连接到容器上</p><p><strong>E.g.</strong></p><div class="macos language-bash line-numbers-mode" data-ext="sh"><pre class="language-bash"><code><span class="token comment"># 查看列表</span>
<span class="token function">docker</span> <span class="token function">ps</span> <span class="token parameter variable">-a</span>
<span class="token comment"># 使用容器ID选中STATUS是Created的容器启动， 并将当前终端连接到容器</span>
<span class="token function">docker</span> start <span class="token parameter variable">-a</span> 2zoi
</code></pre><div class="line-numbers" aria-hidden="true"><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div></div></div></li><li><p>运行 <code>docker run [OPTIONS] IMAGE [COMMAND] [ARG...]</code></p><p>-t, --tty 分配一个伪TTY，也就是分配虚拟终端</p><p>-i, --interactive 即使没有连接，也要保持STDIN打开</p><p>--name 为容器起名，如果没有指定将会随机产生一个名称</p><p>-d, --detach 在后台运行容器并打印出容器ID</p><p>--rm 当容器退出运行后，自动删除容器</p><ul><li><p><code>[COMMAND]</code>: 容器启动后，需要在容器中执行的命令，如ps、ls 等命令</p></li><li><p><code>[ARG...]</code>: 执行 COMMAND 时需要提供的一些参数，如ps 命令的 aux、ls命令的-a等等</p></li></ul><p><strong>P.S.</strong></p><ul><li><p>docker run 相当于 docker create + docker start –a 前台模式，自动连接命令行</p></li><li><p>docker run -d 相当于 docker create + docker start 后台模式，不连接命令行</p></li></ul><p><strong>E.g.</strong></p><div class="macos language-bash line-numbers-mode" data-ext="sh"><pre class="language-bash"><code><span class="token comment"># 执行 ps -A 命令来列出所有的进程，没有-d，执行完 ps 后自动进入 exited 状态</span>
<span class="token function">docker</span> run centos <span class="token function">ps</span> <span class="token parameter variable">-A</span>
<span class="token comment"># std输出容器id，ps -A 在后台执行，不会直接看到结果，执行完 ps 后自动进入 exited 状态</span>
<span class="token function">docker</span> run <span class="token parameter variable">-d</span> centos <span class="token function">ps</span> <span class="token parameter variable">-A</span>
<span class="token comment"># std输出容器id，后台执行完 ps -A 后，由于 --rm 直接删除</span>
<span class="token function">docker</span> run <span class="token parameter variable">--rm</span> <span class="token parameter variable">-d</span> centos <span class="token function">ps</span> <span class="token parameter variable">-A</span>
</code></pre><div class="line-numbers" aria-hidden="true"><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div></div></div></li><li><p>暂停 <code>docker pause CONTAINER [CONTAINER...]</code> 将 running 状态的容器切换到 paused 状态</p></li><li><p>恢复 <code>docker unpause CONTAINER [CONTAINER...]</code> 将 paused 状态的容器切换到 running 状态</p></li><li><p>关闭 <code>docker stop [OPTIONS] CONTAINER [CONTAINER...]</code> 将 paused 状态的容器切换到 exited 状态</p><p>-t, --time int 关闭前，等待的时间，单位秒(默认 10s)</p></li><li><p>强制关闭 <code>docker kill [OPTIONS] CONTAINER [CONTAINER...]</code> 强制并立即将一个或多个 paused 状态容器切换到 exited 状态</p><p>-s, --signal string 指定发送给容器的关闭信号 (默认“KILL”信号)</p><p><strong>P.S.</strong></p><ul><li><p><code>stop</code> 使用 SIGTERM 信号，如果设置了-t且超出时间，则使用 SIGKILL</p></li><li><p><code>kill</code> 默认使用 SIGKILL 信号</p></li><li><p>异常原因会导致容器关闭</p></li></ul></li><li><p>重启 <code>docker restart [OPTIONS] CONTAINER [CONTAINER...]</code> 将 running/exited/paused/created 状态容器重新进入 running状态</p><p>-t, --time int 重启（关闭）前，等待的时间，单位秒(默认 10s)</p></li><li><p>删除 <code>docker (container) rm [OPTIONS] CONTAINER [CONTAINER...]</code></p><p>-f, --force 强行删除容器(会使用 SIGKILL信号)</p><p>-v, --volumes 同时删除绑定在容器上的数据卷</p></li><li><p>检视 <code>docker container inspect [OPTIONS] CONTAINER [CONTAINER...]</code> 查看容器详情</p><p>-f, --format string 利用特定Go语言的format格式输出结果</p><p>-s, --size 显示总大小</p><p><strong>E.g.</strong></p><div class="macos language-bash line-numbers-mode" data-ext="sh"><pre class="language-bash"><code><span class="token comment"># 使用容器ID输出信息json</span>
<span class="token function">docker</span> container inspect 2zoi
<span class="token comment"># 输出信息json中State字段的内容</span>
<span class="token function">docker</span> container inspect <span class="token parameter variable">-f</span> <span class="token string">&quot;{{json .State.Status}}&quot;</span> 2zoi
</code></pre><div class="line-numbers" aria-hidden="true"><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div></div></div></li><li><p>日志 <code>docker logs [OPTIONS] CONTAINER</code> 容器主进程的输出STDOUT\\STDERR</p><p>--details 显示日志的额外信息</p><p>-f, --follow 动态跟踪显示日志信息</p><p>--since string 只显示某事时间节点之后的</p><p>--tail string 显示倒数的行数(默认全部)</p><p>-t, --timestamps 显示timestamps时间</p><p>--until string 只显示某事时间节点之前的</p></li><li><p>重命名 <code>docker rename CONTAINER NEW_NAME</code></p></li><li><p>连接 <code>docker attach [OPTIONS] CONTAINER</code> 将当前终端的标准输入输出流连接到容器内</p><p>--no-stdin 不绑定STDIN</p><div class="macos language-bash line-numbers-mode" data-ext="sh"><pre class="language-bash"><code><span class="token comment"># 连接到容器的主进程（通常是 CMD 或 ENTRYPOINT 启动的进程）</span>
<span class="token function">docker</span> attach <span class="token operator">&lt;</span>容器ID或容器名<span class="token operator">&gt;</span>
<span class="token comment"># 退出时如果直接按 Ctrl+C 可能会导致容器停止。</span>
<span class="token comment"># 分离（不关闭容器）：Ctrl + p 然后 Ctrl + q</span>
<span class="token comment"># 关闭容器：exit 或 Ctrl + C</span>
</code></pre><div class="line-numbers" aria-hidden="true"><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div></div></div></li><li><p>执行命令 <code>docker exec [OPTIONS] CONTAINER COMMAND [ARG...]</code> 容器中允许一个命令</p><p>-d, --detach 后台运行命令</p><p>-i, --interactive 即使没连接容器，也将当前的STDIN绑定上</p><p>-t, --tty 分配一个虚拟终端</p><p>-w, --workdir string 指定在容器中的工作目录</p><p>-e, --env list 设置容器中运行时的环境变量</p><div class="macos language-bash line-numbers-mode" data-ext="sh"><pre class="language-bash"><code><span class="token function">docker</span> <span class="token builtin class-name">exec</span> <span class="token parameter variable">-it</span> <span class="token operator">&lt;</span>容器ID或容器名<span class="token operator">&gt;</span> <span class="token function">bash</span>
<span class="token comment"># 如果容器里没有 bash，可以换成 sh</span>
<span class="token function">docker</span> <span class="token builtin class-name">exec</span> <span class="token parameter variable">-it</span> <span class="token operator">&lt;</span>容器ID或容器名<span class="token operator">&gt;</span> <span class="token function">sh</span>
</code></pre><div class="line-numbers" aria-hidden="true"><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div></div></div></li></ul><h3 id="容器与镜像的关系" tabindex="-1"><a class="header-anchor" href="#容器与镜像的关系" aria-hidden="true">#</a> 容器与镜像的关系</h3><p><img src="`+d+`" alt="容器与镜像"></p><ul><li><p>提交 <code>docker commit [OPTIONS] CONTAINER [REPOSITORY[:TAG]]</code> 根据容器生成一个新的镜像</p><p>-a, --author string 作者</p><p>-c, --change list 为创建的镜像加入Dockerfile命令</p><p>-m, --message string 提交信息，类似git commit -m</p><p>-p, --pause 提交时暂停容器 (default true)</p><p><strong>E.g.</strong></p><div class="macos language-bash line-numbers-mode" data-ext="sh"><pre class="language-bash"><code><span class="token comment"># 启动一个容器</span>
<span class="token function">docker</span> run <span class="token parameter variable">--rm</span> <span class="token parameter variable">-dit</span> centos <span class="token function">bash</span>
<span class="token comment"># 通过容器ID为容器安装软件</span>
<span class="token function">docker</span> <span class="token builtin class-name">exec</span> <span class="token parameter variable">-d</span> 2zoi yum <span class="token parameter variable">-y</span> <span class="token function">install</span> net-tools
<span class="token comment"># 通过容器ID提交生成一个新镜像</span>
<span class="token function">docker</span> commit <span class="token parameter variable">-m</span> <span class="token string">&#39;install net-tools&#39;</span> 2zoi centos-net-tools:latest
<span class="token comment"># 查看镜像列表，可发现刚刚生成的镜像</span>
<span class="token function">docker</span> images
</code></pre><div class="line-numbers" aria-hidden="true"><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div></div></div></li><li><p>导出 <code>docker export [OPTIONS] CONTAINER</code> 将容器当前的文件系统导出成一个tar文件</p><p>-o, --output string 指定写入的文件，默认是STDOUT</p></li><li><p>导入 <code>docker import [OPTIONS] file|URL|- [REPOSITORY[:TAG]]</code> 从一个tar文件中导入内容创建一个镜像</p><p>-c, --change list 为创建的镜像加入Dockerfile命令</p><p>-m, --message string 导入时，添加提交信息</p><p><strong>P.S.</strong>: <code>commit</code> 与 <code>import</code> 构建出镜像的区别</p><ul><li><p>使用 <code>history</code> 查看分层信息可查出区别</p><ul><li><p><code>commit</code> 生成的镜像拥有多个层。保留了原本镜像的分层信息，后续操作在其上构建了新层 （保留历史信息）</p></li><li><p><code>import</code> 只有一个层。将原本镜像的分层与操作后的内容合并为一个层 （无历史信息，创建全新）</p></li></ul></li><li><p>使用 <code>inspect</code> 查看详细信息中的 <em>config</em> 字段 与 <em>RootFS</em> 中的 <em>Layers</em></p><ul><li><p><code>commit</code> 的镜像会保留并更新原始镜像的 <em>config</em> 数据，<em>Layers</em> 会保留并新增层</p></li><li><p><code>import</code> 会丢失 <em>config</em> 字段数据，</p></li></ul></li></ul></li></ul><p><strong>生成镜像的层级</strong>：<code>inspect</code> 详细信息 <em>RootFS</em> 中的 <em>Layers</em> 数组，按照 <code>history</code> 层级从底向上， 记录<strong>文件发生变动的层</strong>（即：只有 <code>history</code> 的层级中，文件发生变动的层才会在 <em>RootFS</em> 中的 <em>Layers</em> 数组里存在）。镜像中的每一层都是只读的</p><p><strong>容器的层级</strong>：<code>create</code>/<code>run</code> 会在镜像顶层的只读层上，再创建一个可读写层（联合文件系统，下方所有层的叠加，访问时访问的是前面所有层叠加的结果）。在执行 <code>commit</code> 之后（容器变成镜像），顶层的可读写层会转换成只读层</p><h2 id="网络" tabindex="-1"><a class="header-anchor" href="#网络" aria-hidden="true">#</a> 网络</h2><p>容器与宿主，容器间的网络默认是隔离的</p><h3 id="网络驱动模式" tabindex="-1"><a class="header-anchor" href="#网络驱动模式" aria-hidden="true">#</a> 网络驱动模式</h3><ul><li><p>bridge network 模式（网桥）：默认的网络模式。类似虚拟机的nat模式</p><ul><li><p>宿主机上需要单独的bridge网卡（新建bridge网络后，通过ifconfig可查看该网卡），如默认docker默认创建的docker0</p></li><li><p>容器之间、容器与主机之间的网络通信，是借助为每一个容器生成的一对veth pair虚拟网络设备对，进行通信的。一个在容器上，另一个在宿主机上</p></li><li><p>每创建一个基于bridge网络的容器，都会自动在宿主机上创建一个veth...虚拟网络设备（ifconfig可查看该虚拟网卡）</p></li><li><p>外部无法直接访问容器。需要建立 <strong>端口映射</strong> 才能访问</p><p>-P, --publish-all 将容器内部所有暴露端口进行随机映射，<code>docker ps -a</code> 查看映射情况</p><p>-p, --publish list 手动指定端口映射 [HOST_IP]:[HOST_PORT]:CONTAINER_PORT</p></li><li><p>容器借由veth虚拟设备通过如docker0这种bridge网络设备进行通信</p></li><li><p>每一容器具有单独的IP</p></li><li><p><strong>容器间通信</strong>: 使用同一个bridge，可使用 <code>http://容器名:暴露端口</code> 进行访问</p></li></ul></li><li><p>host network 模式（主机）：容器与宿主机之间的网络无隔离，即容器直接使用宿主机网络，容器的IP就是宿主机的IP</p><ul><li><p>容器完全共享宿主机的网络。网络没有隔离。宿主机的网络就是容器的网络</p></li><li><p>容器、主机上的应用所使用的端口不能重复。例如：如果宿主机已经占用了8090端口，那么任何一个host模式的容器都不可以使用8090端口了；反之同理</p></li><li><p>外部可以直接使用宿主机IP+容器端口端口访问对应容器，不需要端口映射。此时启动容器与启动本地应用的感知一样</p></li></ul></li><li><p>None network 模式：容器禁用所有网络。高度定制网络时使用该模式自行安装与配置</p></li><li><p>Overlay network 模式（覆盖网络）： 利用VXLAN实现的bridge模式。常用于不同主机内容器的通信（虽然前两种也能实现，但多容器时，bridge容器IP过多且端口映射复杂，host容易端口占用且网卡压力大）</p><p><img src="`+r+`" alt="Overlay"></p><ul><li><p>在容器内网络层封装数据包时，额外多封装了一个IP头部。而后将报文提交到宿主机</p></li><li><p>宿主机将报文作为VXLAN，再次封装，传输层增加了UDP头，网络层增加IP头，以此类推。而后进行发送</p></li></ul></li><li><p>Macvlan network 模式：容器具备Mac地址，使其显示为网络上的物理设备。宿主机充当交换机，采用mac地址表，根据mac地址进行转发。容器对外相当于一台独立的设备</p></li><li><p>Container network 模式。容器使用其他容器的网络，来实现间的网络不隔离。容器1使用host，容器2使用Container则也为host；容器1为bridge，容器2使用Container则会与容器1同IP（使用容器1的veth pair）。若容器暴露相同端口，将由于端口占用而容器启动失败</p></li></ul><p><strong>P.S.</strong>：host模式性能最好，overlay需要再次封装，性能低于bridge</p><h3 id="网络管理命令" tabindex="-1"><a class="header-anchor" href="#网络管理命令" aria-hidden="true">#</a> 网络管理命令</h3><ul><li><p>查看 <code>docker network ls [OPTIONS]</code> 查看已经建立的网络对象</p><p>-f, --filter filter 过滤条件(如 &#39;driver=bridge’)</p><p>--format string 格式化打印结果</p><p>--no-trunc 不缩略显示</p><p>-q, --quiet 只显示网络对象的ID</p><p><strong>E.g.</strong> <code>docker network ls -f &#39;driver=host&#39;</code> 查看 host 模式的网络对象列表</p></li><li><p>创建 <code>docker network create [OPTIONS] NETWORK</code> 创建网络对象</p><p>-d, --driver string 指定网络的驱动(默认 &quot;bridge&quot;)</p><p>--subnet strings 指定子网网段(如192.168.0.0/16、172.88.0.0/24)</p><p>--ip-range strings 执行容器的IP范围，格式同subnet参数（subnet子集）</p><p>--gateway strings 子网的IPv4 or IPv6网关，如(192.168.0.1)</p><p><strong>P.S.</strong></p><ul><li>host和none模式网络对象只能存在一个</li><li>docker自带的overlay 网络创建依赖于docker swarm(集群负载均衡)服务</li><li>192.168.0.0/16(前16位固定，0.0-255.255) 192.168.8.0/24(0-255)</li></ul><p><strong>E.g.</strong> 定制化一个bridge类型网络</p><div class="macos language-bash line-numbers-mode" data-ext="sh"><pre class="language-bash"><code><span class="token comment"># 定制化网段 ，ip范围，网关地址</span>
<span class="token function">docker</span> network create <span class="token parameter variable">--subnet</span> <span class="token number">172.168</span>.0.0/16 --ip-range <span class="token number">172.168</span>.50.0/24 <span class="token parameter variable">--gateway</span> <span class="token number">172.168</span>.50.1 my-bridge
</code></pre><div class="line-numbers" aria-hidden="true"><div class="line-number"></div><div class="line-number"></div></div></div></li><li><p>删除 <code>docker network rm NETWORK [NETWORK...]</code> 支持name或id</p></li><li><p>检视 <code>docker (network) inspect [OPTIONS] NETWORK [NETWORK...]</code> 查看一个或多个网络的详细信息</p><p>-f, --format string 根据format输出结果</p></li><li><p>使用 <code>docker run/create --network NETWORK</code> 容器默认使用bridge网络</p><p><strong>E.g.</strong></p><div class="macos language-bash line-numbers-mode" data-ext="sh"><pre class="language-bash"><code><span class="token comment"># 使用自创建的网络启动FastDFS中的tracker服务, 端口映射 宿主机端口:容器端口</span>
<span class="token function">docker</span> run <span class="token parameter variable">-d</span> <span class="token parameter variable">-p</span> :22122:22122 <span class="token parameter variable">--name</span> tracker <span class="token parameter variable">--net</span><span class="token operator">=</span>my-net  <span class="token parameter variable">-v</span> /var/fdfs/tracker:/var/fdfs delron/fastdfs tracker
<span class="token comment"># 使用Container模式 --network container:CONTAINER</span>
<span class="token function">docker</span> run 
</code></pre><div class="line-numbers" aria-hidden="true"><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div></div></div></li><li><p>连接与断开 <code>docker network connect/(disconnect) [OPTIONS] NETWORK CONTAINER</code> host与overlay网络无法连接。none可以连接。none与bridge不能共存。overlay不能与其他模式共存</p></li></ul><h2 id="数据卷" tabindex="-1"><a class="header-anchor" href="#数据卷" aria-hidden="true">#</a> 数据卷</h2><p>为了解决容器内文件的存储与访问时产生的各种问题，引入了数据卷机制。</p><ul><li><p>数据卷存在于宿主机中，与容器隔离</p></li><li><p>可利用数据卷解决容器与宿主，和容器间的数据共享问题</p></li><li><p>容器启动初始化时，如果容器使用的镜像包含了数据，这些数据会拷贝到数据卷中</p></li><li><p>容器对数据卷的修改是实时的</p></li><li><p>数据卷变化不会影响镜像。数据卷独立与联合文件系统，镜像基于联合文件系统</p></li></ul><h3 id="挂载方式" tabindex="-1"><a class="header-anchor" href="#挂载方式" aria-hidden="true">#</a> 挂载方式</h3><p>在执行 <code>docker create / run</code> 时，使用 OPTION 声明数据卷挂载方式(声明路径必须是绝对路径)</p><ul><li><p>bind mounts：将宿主机上的一个文件或目录被挂载到容器上（目录映射）</p><p>方法1: -v, --volume参数 <code>-v &lt;宿主机文件或文件夹路径&gt;:&lt;容器中的文件或者文件夹路径&gt;</code> 自动在宿主机创建文件夹</p><p>方法2: <code>--mount type=bind,src=&lt;宿主机文件或文件夹路径&gt;,dst=&lt;容器中的文件或者文件夹路径&gt;</code> 要求宿主机声明路径必须存在</p></li><li><p>volumes：数据卷对象在宿主机的映射， docker volume 统一管理，可理解为bind方式基础上做了额外封装</p><p>方法1: -v, --volume参数 <code>-v VOLUME-NAME:&lt;容器中的文件或者文件夹路径&gt;</code> 名称不存在的volume对象会自动创建</p><p>方法2: <code>--mount type=volume,src=VOLUME-NAME,dst=&lt;容器中的文件或者文件夹路径&gt;</code> 名称不存在的volume对象会自动创建</p><p>volume对象管理</p><div class="macos language-bash line-numbers-mode" data-ext="sh"><pre class="language-bash"><code><span class="token comment"># 查看对象列表</span>
<span class="token function">docker</span> volume <span class="token function">ls</span>
<span class="token comment"># 创建</span>
<span class="token function">docker</span> volume create VOLUMENAME
<span class="token comment"># 检视 - 可查看该数据卷的本地目录</span>
<span class="token function">docker</span> volume inspect VOLUMENAME
<span class="token comment"># 删除未使用的对象</span>
<span class="token function">docker</span> volume prune
<span class="token comment"># 删除</span>
<span class="token function">docker</span> volume <span class="token function">rm</span> VOLUMENAME<span class="token punctuation">[</span><span class="token punctuation">..</span>VOLUMENAME<span class="token punctuation">]</span>
</code></pre><div class="line-numbers" aria-hidden="true"><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div></div></div></li><li><p>tmpfs mounts：tmpfs 是一种基于内存的临时文件系统。tmpfs mounts 数据不会存储在磁盘上，而是宿主机的内存</p><p>--mount type=tmpfs, dst=PATH</p></li><li><p>使用其他容器的数据卷方式 <code>--volumes from CONTAINER</code></p></li></ul><h3 id="数据卷挂载注意点" tabindex="-1"><a class="header-anchor" href="#数据卷挂载注意点" aria-hidden="true">#</a> 数据卷挂载注意点</h3><p>Docker的数据卷更多会是使用volumes方式</p><ul><li>使用bind方式，通过 <code>--mount</code> 创建时可能会出现异常</li><li>数据卷对象可以使用 <code>docker volume</code> 进行管理</li></ul><p>使用时需注意：</p><ul><li>如果挂载一个空的数据卷到容器中的一个非空目录中，那么这个目录下的文件会被复制到数据卷中（数据卷的初始化）</li><li>如果挂载一个非空的数据卷到容器中的一个目录中，那么容器中的目录中会显示数据卷中的数据。如果原来容器中的目录中有数据，那么这些原始数据会被隐藏掉（已存在数据卷的优先）</li></ul><h2 id="仓库" tabindex="-1"><a class="header-anchor" href="#仓库" aria-hidden="true">#</a> 仓库</h2><blockquote><p>存放镜像，并可使用pull下载镜像的环境 (DockerFile 使用 cloud 可以比仓库更便捷的构建镜像)</p></blockquote><p>私有仓库相对于直接copy压缩包，更易于版本控制</p><h3 id="仓库搭建" tabindex="-1"><a class="header-anchor" href="#仓库搭建" aria-hidden="true">#</a> 仓库搭建</h3><ul><li><p>安装docker</p></li><li><p>获取创建仓库镜像 <code>docker pull registry</code></p></li><li><p>启动仓库(内部会有http服务)</p><div class="macos language-bash line-numbers-mode" data-ext="sh"><pre class="language-bash"><code><span class="token function">docker</span> run <span class="token parameter variable">-d</span> <span class="token parameter variable">-ti</span> <span class="token parameter variable">--restart</span> always<span class="token punctuation">\\</span>  <span class="token comment"># 跟随docker服务一起重启</span>
            <span class="token parameter variable">--name</span> my-registry<span class="token punctuation">\\</span>
            <span class="token parameter variable">-p</span> <span class="token number">8000</span>:5000<span class="token punctuation">\\</span>  <span class="token comment"># 内部服务在5000端口，映射到宿主的8000上 - 本机IP:8000即为仓库地址</span>
            <span class="token parameter variable">-v</span> /my-registry/registry:/var/lib/registry<span class="token punctuation">\\</span>  <span class="token comment"># 镜像存储在本地</span>
registry  <span class="token comment"># 镜像名称</span>
</code></pre><div class="line-numbers" aria-hidden="true"><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div></div></div></li><li><p>查看仓库镜像列表 <code>curl &lt;服务器IP&gt;:8000/v2/_catalog</code></p></li></ul><h3 id="上传与下载" tabindex="-1"><a class="header-anchor" href="#上传与下载" aria-hidden="true">#</a> 上传与下载</h3><ul><li><p>上传</p><ul><li><p>重命名需要上传的镜像 <code>docker tag IMAGE &lt;服务器IP&gt;:&lt;端口&gt;/IMAGE_NAME</code> (注意：此处需要注明仓库地址)</p></li><li><p>上传重命名的镜像 <code>docker push &lt;服务器IP&gt;:&lt;端口&gt;/centos</code> (注意：默认情况下为https服务，会出现异常)</p></li></ul><p><strong>P.S.</strong>：处理HTTPS异常：将该仓库请求变更为http请求 修改docker配置文件 <em>/etc/docker/daemon.json</em> (mac地址 <em>~/.docker/daemon.json</em>)，添加内容解包添加 <code>json { &quot;insecure-registries&quot;:[&quot;&lt;服务器IP&gt;:&lt;端口&gt;&quot;] } </code></p><p>此时使用 <code>docker image ls</code> 可查看到镜像 <code>&lt;IP&gt;:&lt;端口&gt;/镜像名</code></p><p>通过请求 <code>curl &lt;服务器IP&gt;:8000/v2/_catalog</code> 可查看到上传完成的镜像</p></li><li><p>下载 <code>docker pull &lt;服务器IP&gt;:&lt;端口&gt;/IMAGE_NAME</code> (注意：此处需要注明仓库地址，不表明默认从官方 docker hub 上拉取)</p></li></ul><h3 id="仓库的认证配置" tabindex="-1"><a class="header-anchor" href="#仓库的认证配置" aria-hidden="true">#</a> 仓库的认证配置</h3><ul><li>仓库认证 <ul><li>STEP0: 删除先前创建的无认证的仓库容器 <code>docker rm -f my-registry</code> P.S. 如需删除镜像还需删除数据卷，也可直接映射新仓库来继承其镜像</li><li>创建存放认证用户名和密码的文件路径 <code>mkdir /my-registry/auth -p</code></li><li>创建密码验证文件。USERNAME和PASSWORD替换为设置的用户名和密码<div class="macos language-bash line-numbers-mode" data-ext="sh"><pre class="language-bash"><code><span class="token comment"># 运行容器内的 htpasswd 来设置账号密码 写入指定路径</span>
<span class="token function">docker</span> run <span class="token parameter variable">--entrypoint</span> htpasswd registry <span class="token parameter variable">-Bbn</span> USERNAME PASSWORD <span class="token operator">&gt;</span> /my-registry/auth/htpasswd
</code></pre><div class="line-numbers" aria-hidden="true"><div class="line-number"></div><div class="line-number"></div></div></div></li><li>重新启动仓库镜像<div class="macos language-bash line-numbers-mode" data-ext="sh"><pre class="language-bash"><code><span class="token function">docker</span> run <span class="token parameter variable">-d</span> <span class="token parameter variable">-p</span> <span class="token number">8000</span>:5000 <span class="token parameter variable">--restart</span><span class="token operator">=</span>always <span class="token parameter variable">--name</span> docker-registry <span class="token punctuation">\\</span>
<span class="token parameter variable">-v</span> /my-registry/registry:/var/lib/registry <span class="token punctuation">\\</span>  <span class="token comment"># 映射镜像文件夹</span>
<span class="token parameter variable">-v</span> /my-registry/auth:/auth <span class="token punctuation">\\</span>  <span class="token comment"># 映射密码文件夹</span>
<span class="token parameter variable">-e</span> <span class="token string">&quot;REGISTRY_AUTH=htpasswd&quot;</span> <span class="token punctuation">\\</span>  <span class="token comment"># 环境变量</span>
<span class="token parameter variable">-e</span> <span class="token string">&quot;REGISTRY_AUTH_HTPASSWD_REALM=Registry Realm&quot;</span> <span class="token punctuation">\\</span>  <span class="token comment"># 环境变量：认证方式</span>
<span class="token parameter variable">-e</span> <span class="token string">&quot;REGISTRY_AUTH_HTPASSWD_PATH=/auth/htpasswd&quot;</span> <span class="token punctuation">\\</span>  <span class="token comment"># 环境变量：密钥路径</span>
registry
</code></pre><div class="line-numbers" aria-hidden="true"><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div></div></div></li></ul></li><li>上传与下载 <ul><li>登录 <code>docker login -u &lt;username&gt; -p &lt;password&gt; &lt;IP&gt;:&lt;端口&gt;</code></li><li>执行上传 下载操作 (与不带认证的私有仓库操作一致)</li><li>退出登录 <code>docker logout &lt;IP&gt;:&lt;端口&gt;</code></li></ul></li></ul><h2 id="dockerfile" tabindex="-1"><a class="header-anchor" href="#dockerfile" aria-hidden="true">#</a> DockerFile</h2><blockquote><p>包含 <code>docker build</code> 命令的文本文件，通常名称为 <em>Dockerfile</em> ，运行时会依次执行其中命令创建一个新的镜像</p></blockquote><p>运行：<code>docker build &lt;Dockerfile文件所在文件夹路径&gt; -t NAME:TAG</code> P.S. 如果文件名不为 <em>Dockerfile</em> ，需使用 <code>-f</code> 指明文件名</p>`,51),k={href:"https://github.com/docker-library/docs/",target:"_blank",rel:"noopener noreferrer"},v=a('<h3 id="构建" tabindex="-1"><a class="header-anchor" href="#构建" aria-hidden="true">#</a> 构建</h3><p>Dockerfile的构建（镜像 -&gt; 临时容器 -&gt; 镜像）类似于 <code>docker commit</code> 操作（容器 -&gt; 镜像），其中 <strong>每个 <code>FROM</code> 外的命令会在原镜像上新增一层（dockerfile中的命令对应着 <code>docker history</code> 中的一层，<code>FROM</code> 对应着基础镜像的层级，可能为多个）</strong></p><p><strong>构建缓存</strong>：在二次构建时，若dockerfile未发生变动，则直接使用第一次构建的缓存（<code>docker images</code> 中存在的上一次构建的镜像）。若dockerfile发生变动，则变动处及后方都是重新执行（变动处开始不使用缓存，之前位置使用上次构建的镜像）。 在更新Dockerfile时，一般在文件末尾添加，不会变动到之前的内容，以防止二次初始化造成数据丢失</p><h3 id="命令" tabindex="-1"><a class="header-anchor" href="#命令" aria-hidden="true">#</a> 命令</h3>',4),b={href:"https://docs.docker.com/reference/dockerfile/",target:"_blank",rel:"noopener noreferrer"},g=a(`<ul><li><p><code>FROM</code>: 指定基础镜像。在指定镜像上构建新的镜像</p></li><li><p><code>RUN</code>: 构建镜像过程（ <code>docker build</code> 过程）中需要执行的命令。可以有多条。在 <code>docker build</code> 时调用 <code>RUN</code> 中的命令</p><div class="language-docker line-numbers-mode" data-ext="docker"><pre class="language-docker"><code><span class="token comment"># shell方式运行命令（子进程）：RUN + 命令 (推荐)</span>
<span class="token instruction"><span class="token keyword">RUN</span> echo <span class="token string">&#39;test&#39;</span></span>
<span class="token comment"># exec方式运行命令（当前进程）：RUN + 命令数组</span>
<span class="token instruction"><span class="token keyword">RUN</span> [<span class="token string">&quot;yum&quot;</span>, <span class="token string">&quot;install&quot;</span>, <span class="token string">&quot;-y&quot;</span>, <span class="token string">&quot;net-tools&quot;</span>]</span>
</code></pre><div class="line-numbers" aria-hidden="true"><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div></div></div><p><strong>说明：</strong> linux执行方式</p><ul><li><p>shell方式执行 <code>/bin/sh -c echo &quot;test&quot;</code> ，此时会开辟子进程执行，当前窗口无法看到输出</p></li><li><p>exec方式执行 <code>exec echo &quot;test&quot;</code> ，此时会先kill当前在当前窗口执行，且执行完成后终端被结束(dockerfile中的环境变量会受影响 / 可使用 <code>exec sh -c</code> 避免)</p></li></ul></li><li><p><code>CMD</code>: 添加启动容器时需要执行的命令（ <code>docker inspect</code> 检视镜像CMD信息 <em>Config.Cmd</em> 字段 ）。多条只有最后一条生效。可以在启动容器时被覆盖和修改（当执行 <code>docker run [OPTIONS] IMAGE [COMMAND] [ARG...]</code> 时，没有提供 COMMAND ，将默认执行 <em>Config.Cmd</em> 中的内容）</p><div class="language-docker line-numbers-mode" data-ext="docker"><pre class="language-docker"><code>
<span class="token comment"># 命令（子进程）将以shell方式运行：CMD + 命令</span>
<span class="token instruction"><span class="token keyword">CMD</span> echo <span class="token string">&#39;test&#39;</span></span>
<span class="token comment"># 命令（当前进程）将exec方式运行：CMD + 命令数组 （推荐，通常使用CMD启动程序主程序，绑定容器生命周期）</span>
<span class="token instruction"><span class="token keyword">CMD</span> [<span class="token string">&quot;yum&quot;</span>, <span class="token string">&quot;install&quot;</span>, <span class="token string">&quot;-y&quot;</span>, <span class="token string">&quot;net-tools&quot;</span>]</span>
<span class="token comment"># 后续内容作为 ENTRYPOINT 命令的参数</span>
<span class="token instruction"><span class="token keyword">CMD</span> [<span class="token string">&quot;params1&quot;</span>, <span class="token string">&quot;params2&quot;</span>]</span>
</code></pre><div class="line-numbers" aria-hidden="true"><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div></div></div></li><li><p><code>ENTRYPOINT</code>: 同CMD，但这个一定会被执行，不会被覆盖修改</p><div class="language-docker line-numbers-mode" data-ext="docker"><pre class="language-docker"><code><span class="token comment"># 命令（子进程）将以shell方式运行：ENTRYPOINT + 命令</span>
<span class="token instruction"><span class="token keyword">ENTRYPOINT</span> echo <span class="token string">&#39;test&#39;</span></span>
<span class="token comment"># 命令（当前进程）将exec方式运行：ENTRYPOINT + 命令数组 （推荐，通常使用ENTRYPOINT启动程序主程序，绑定容器生命周期）</span>
<span class="token instruction"><span class="token keyword">ENTRYPOINT</span> [<span class="token string">&quot;yum&quot;</span>, <span class="token string">&quot;install&quot;</span>, <span class="token string">&quot;-y&quot;</span>, <span class="token string">&quot;net-tools&quot;</span>]</span>
</code></pre><div class="line-numbers" aria-hidden="true"><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div></div></div></li><li><p><code>LABEL</code>: 为镜像添加对应的数据。<code>docker inspect</code> 检视镜像Labels信息 <em>Config.Labels</em> 字段。版本、名称、协议等说明信息</p></li><li><p><code>MAINTAINER</code>: 表明镜像的作者。将被遗弃，被LABEL代替。<code>docker inspect</code> 检视镜像Author信息 <em>Author</em> 字段</p></li><li><p><code>EXPOSE</code>: 设置对外暴露的端口。<code>docker inspect</code> 检视镜像暴露端口 <em>Config.ExposedPorts</em> 字段</p><div class="language-docker line-numbers-mode" data-ext="docker"><pre class="language-docker"><code><span class="token comment"># 暴露端口（默认TCP）</span>
<span class="token instruction"><span class="token keyword">EXPOSE</span> 6379</span>
<span class="token comment"># 指定端口协议</span>
<span class="token instruction"><span class="token keyword">EXPOSE</span> 80/tcp</span>
<span class="token instruction"><span class="token keyword">EXPOSE</span> 80/udp</span>
</code></pre><div class="line-numbers" aria-hidden="true"><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div></div></div></li><li><p><code>ENV</code>: 设置执行命令时的环境变量，并且在构建完成后，仍然生效</p></li><li><p><code>ARG</code>: 设置只在构建过程( <code>docker build</code> 过程 )中使用的环境变量（如 <code>docker build</code> 时传入的参数值），构建完成后，将消失</p><p>使用arg动态接收username值 <code>docker build --build-arg username=what_user .</code></p><div class="language-docker line-numbers-mode" data-ext="docker"><pre class="language-docker"><code><span class="token instruction"><span class="token keyword">FROM</span> busybox</span>
<span class="token instruction"><span class="token keyword">USER</span> <span class="token variable">\${username:-some_user}</span></span>
<span class="token instruction"><span class="token keyword">ARG</span> username</span>
<span class="token instruction"><span class="token keyword">USER</span> <span class="token variable">$username</span></span>
</code></pre><div class="line-numbers" aria-hidden="true"><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div></div></div></li><li><p><code>ADD</code>: 将本地文件或目录拷贝到镜像的文件系统中。能解压特定格式文件，能将URL作为要拷贝的文件</p></li><li><p><code>COPY</code>: 将本地文件或目录拷贝到镜像的文件系统中。</p></li><li><p><code>VOLUME</code>: 添加数据卷（自动创建数据卷）如：<code>docker run -dit redis</code> ，由于其dockerfile内设置了<code>VOLUME</code>，将自动创建数据，等效为 <code>docker run -dit -v /data redis</code></p></li><li><p><code>USER</code>: 指定以哪个用户的名义执行RUN, CMD 和ENTRYPOINT等命令</p></li><li><p><code>WORKDIR</code>: 设置工作目录。明确 <code>RUN</code> 的工作路径</p></li><li><p><code>ONBUILD</code>: 如果制作的镜像被另一个Dockerfile使用（创建出的镜像被另一个dockerfile <code>FROM</code>），将在那里被执行Docekrfile命令</p></li><li><p><code>STOPSIGNAL</code>: 设置容器退出时发出的关闭信号。<code>kill -l</code> 可查看全部关闭信号</p></li><li><p><code>HEALTHCHECK</code>: 设置容器状态检查。设置指定时间间隔执行指定命令用于检测运行状态并记录</p></li><li><p><code>SHELL</code>: 更改执行shell命令的程序。Linux的默认shell是[&quot;/bin/sh&quot;, &quot;-c&quot;]，Windows的是[&quot;cmd&quot;, &quot;/S&quot;, &quot;/C&quot;]。例如 <code>SHELL [&quot;powershell&quot;, &quot;-command&quot;]</code> 切换到powershell</p><div class="language-docker line-numbers-mode" data-ext="docker"><pre class="language-docker"><code><span class="token instruction"><span class="token keyword">FROM</span> microsoft/windowsservercore</span>

<span class="token comment"># Executed as cmd /S /C echo default</span>
<span class="token instruction"><span class="token keyword">RUN</span> echo default</span>

<span class="token comment"># Executed as cmd /S /C powershell -command Write-Host default</span>
<span class="token instruction"><span class="token keyword">RUN</span> powershell -command Write-Host default</span>

<span class="token comment"># 切换到 powershell</span>
<span class="token instruction"><span class="token keyword">SHELL</span> [<span class="token string">&quot;powershell&quot;</span>, <span class="token string">&quot;-command&quot;</span>]</span>
<span class="token instruction"><span class="token keyword">RUN</span> Write-Host hello</span>

<span class="token comment"># 切换会cmd</span>
<span class="token instruction"><span class="token keyword">SHELL</span> [<span class="token string">&quot;cmd&quot;</span>, <span class="token string">&quot;/S&quot;</span>, <span class="token string">&quot;/C&quot;</span>]</span>
<span class="token instruction"><span class="token keyword">RUN</span> echo hello</span>
</code></pre><div class="line-numbers" aria-hidden="true"><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div></div></div></li></ul><h2 id="docker-compose" tabindex="-1"><a class="header-anchor" href="#docker-compose" aria-hidden="true">#</a> Docker Compose</h2><blockquote><p>docker compose用于解决容器固定化流程启动、多容器启动等容器启动的问题。通常名称为 <em>docker-compose.yaml</em></p></blockquote><p>Docker Compose File 配置启动文件，配置镜像/Dockerfile，网络等信息</p><p>Docker Compose Cli - 与docker cli类型</p><p><strong>与Dockerfile的不同</strong>: Dockerfile用于构造镜像。镜像在运行成容器时，需要使用cli管理其网络，数据卷，生命周期（容器起停）。Docker Compose可以对这些内容进行管理（与Docker cli类型，但可一次管理多个）</p><h3 id="安装" tabindex="-1"><a class="header-anchor" href="#安装" aria-hidden="true">#</a> 安装</h3><ul><li><p>windows 与 mac 系统的 docker desktop 自带docker compose</p></li><li><p>Linux 系统需要额外安装</p><ul><li><p><code>sudo curl -L https://github.com/docker/compose/releases/download/版本/docker-compose-$(uname -s)-$(uname -m) -o /usr/local/bin/docker-compose</code></p></li><li><p><code>sudo chmod +x /usr/local/bin/docker-compose</code></p></li><li><p>确定是否安装成功 <code>docker-compose --version</code></p></li></ul></li></ul><h3 id="docker-compose-file" tabindex="-1"><a class="header-anchor" href="#docker-compose-file" aria-hidden="true">#</a> docker compose file</h3><p>docker compose file 采用yaml进行配置。语法目前共3个大版本，且向后兼容（新版本docker引擎支持老版本语言）</p><ul><li>常用配置项 <ul><li><p>version（必须声明）: 指定Docker Compose File版本号</p></li><li><p>services（必须声明）: 定义多个服务并配置启动参数</p><ul><li><p>build: 容器使用 dockerfile 启动时，dockerfile 相关内容</p><div class="language-yaml line-numbers-mode" data-ext="yml"><pre class="language-yaml"><code><span class="token key atrule">version</span><span class="token punctuation">:</span> <span class="token string">&#39;3&#39;</span>
<span class="token key atrule">services</span><span class="token punctuation">:</span>
    <span class="token key atrule">webapp</span><span class="token punctuation">:</span>  <span class="token comment"># 服务名</span>
        <span class="token key atrule">build</span><span class="token punctuation">:</span>
            <span class="token key atrule">context</span><span class="token punctuation">:</span> ./dir  <span class="token comment"># dockerfile所在路径</span>
            <span class="token key atrule">dockerfile</span><span class="token punctuation">:</span> Dockerfile<span class="token punctuation">-</span>alternate  <span class="token comment"># dockerfile名称</span>
            <span class="token key atrule">args</span><span class="token punctuation">:</span>
                <span class="token key atrule">buildno</span><span class="token punctuation">:</span> <span class="token number">1</span>  <span class="token comment"># dockerfile ARG参数</span>
</code></pre><div class="line-numbers" aria-hidden="true"><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div></div></div></li><li><p>command: 重写 <code>inspect</code> 镜像 CMD参数(一些镜像默认配置了CMD)</p></li><li><p>container_name: 容器名称</p></li><li><p>deploy: 多台主机的多容器部署使用</p></li><li><p>depends_on: 容器间的依赖关系，控制容器启动顺序</p><div class="language-yaml line-numbers-mode" data-ext="yml"><pre class="language-yaml"><code><span class="token key atrule">version</span><span class="token punctuation">:</span> <span class="token string">&#39;3&#39;</span>
<span class="token key atrule">services</span><span class="token punctuation">:</span>
    <span class="token key atrule">webapp</span><span class="token punctuation">:</span>  <span class="token comment"># 服务名</span>
        <span class="token key atrule">build</span><span class="token punctuation">:</span> .  <span class="token comment"># 使用dockerfile启动，声明 dockerfile 路径</span>
        <span class="token key atrule">depends_on</span><span class="token punctuation">:</span>  <span class="token comment"># 声明该服务依赖的其他容器，在下列容器启动后再启动</span>
            <span class="token punctuation">-</span> redis
            <span class="token punctuation">-</span> db
    <span class="token key atrule">redis</span><span class="token punctuation">:</span>
        <span class="token key atrule">image</span><span class="token punctuation">:</span> redis  <span class="token comment"># 使用镜像启动，声明镜像名</span>
    <span class="token key atrule">db</span><span class="token punctuation">:</span>
        <span class="token key atrule">image</span><span class="token punctuation">:</span> postgres  <span class="token comment"># 使用镜像启动，声明镜像名</span>
</code></pre><div class="line-numbers" aria-hidden="true"><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div></div></div></li><li><p>entrypoint: 重写 <code>inspect</code> 镜像 ENTRYPOINT 参数重写(一些镜像默认配置了ENTRYPOINT)</p></li><li><p>env_file: 环境变量文件</p><div class="language-yaml line-numbers-mode" data-ext="yml"><pre class="language-yaml"><code><span class="token key atrule">env_file</span><span class="token punctuation">:</span> .env  <span class="token comment"># 支持单文件导入</span>
<span class="token key atrule">env_file</span><span class="token punctuation">:</span>  <span class="token comment"># 支持多文件导入</span>
    <span class="token punctuation">-</span> ./common.env
    <span class="token punctuation">-</span> ./apps/web.env
    <span class="token punctuation">-</span> ./opt/secrets.env
</code></pre><div class="line-numbers" aria-hidden="true"><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div></div></div></li><li><p>environment: 环境变量</p><div class="language-yaml line-numbers-mode" data-ext="yml"><pre class="language-yaml"><code><span class="token key atrule">environment</span><span class="token punctuation">:</span>
    <span class="token punctuation">-</span> FLASK_ENV=development
    <span class="token punctuation">-</span> SECRET=<span class="token important">****</span>
</code></pre><div class="line-numbers" aria-hidden="true"><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div></div></div></li><li><p>expose: 容器暴露端口，此配置项不做映射(一些镜像默认绑定了数据卷)</p><div class="language-yaml line-numbers-mode" data-ext="yml"><pre class="language-yaml"><code><span class="token key atrule">expose</span><span class="token punctuation">:</span>
    <span class="token punctuation">-</span> <span class="token string">&quot;5000&quot;</span>
    <span class="token punctuation">-</span> <span class="token string">&quot;8000&quot;</span>
</code></pre><div class="line-numbers" aria-hidden="true"><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div></div></div></li><li><p>ports: 容器暴露端口，并进行映射(一些镜像默认绑定了数据卷)</p><div class="language-yaml line-numbers-mode" data-ext="yml"><pre class="language-yaml"><code><span class="token key atrule">ports</span><span class="token punctuation">:</span>
    <span class="token punctuation">-</span> <span class="token string">&quot;3000&quot;</span>  <span class="token comment"># 暴露3000 做随机映射</span>
    <span class="token punctuation">-</span> <span class="token string">&quot;3000-3005&quot;</span>  <span class="token comment"># 暴露3000-3005 做随机映射</span>
    <span class="token punctuation">-</span> <span class="token string">&quot;8000:8000&quot;</span>  <span class="token comment"># 8000映射8000</span>
</code></pre><div class="line-numbers" aria-hidden="true"><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div></div></div></li><li><p>image: 同级含有<code>build</code>，则表示dockerfile构建出的镜像的名称。否则，表示启动指定名称的镜像</p></li><li><p>volumes: 绑定数据卷</p><p><strong>P.S.</strong></p><ul><li>一些镜像默认绑定了数据卷，不进行变动时无需再此处再次声明</li><li>在不进行声明时，更新 compose file 后使用 <code>up</code> 而触发容器重构，不会更新数据卷。但 <code>down</code> 会更新数据卷（可能导致数据丢失）</li></ul><div class="language-yaml line-numbers-mode" data-ext="yml"><pre class="language-yaml"><code><span class="token key atrule">version</span><span class="token punctuation">:</span> <span class="token string">&quot;3.2&quot;</span>
<span class="token key atrule">services</span><span class="token punctuation">:</span>
  <span class="token key atrule">web</span><span class="token punctuation">:</span>
    <span class="token key atrule">image</span><span class="token punctuation">:</span> nginx<span class="token punctuation">:</span>alpine
    <span class="token key atrule">volumes</span><span class="token punctuation">:</span>  <span class="token comment"># 引用声明的数据卷</span>
      <span class="token punctuation">-</span> <span class="token key atrule">type</span><span class="token punctuation">:</span> volume
        <span class="token key atrule">source</span><span class="token punctuation">:</span> mydata
        <span class="token key atrule">target</span><span class="token punctuation">:</span> /data
        <span class="token key atrule">volume</span><span class="token punctuation">:</span>
            <span class="token key atrule">nocopy</span><span class="token punctuation">:</span> <span class="token boolean important">true</span>
      <span class="token punctuation">-</span> <span class="token key atrule">type</span><span class="token punctuation">:</span> bind
        <span class="token key atrule">source</span><span class="token punctuation">:</span> ./static
        <span class="token key atrule">target</span><span class="token punctuation">:</span> /opt/app/static

  <span class="token key atrule">db</span><span class="token punctuation">:</span>
    <span class="token key atrule">image</span><span class="token punctuation">:</span> postgres<span class="token punctuation">:</span>latest
    <span class="token key atrule">volumes</span><span class="token punctuation">:</span>
      <span class="token punctuation">-</span> <span class="token string">&quot;/var/run/postgres/postgres.sock:/var/run/postgres/postgres.sock&quot;</span>
      <span class="token punctuation">-</span> <span class="token string">&quot;dbdata:/var/lib/postgresql/data&quot;</span>

<span class="token key atrule">volumes</span><span class="token punctuation">:</span>  <span class="token comment"># 数据卷声明</span>
  <span class="token key atrule">mydata</span><span class="token punctuation">:</span>  <span class="token comment"># 数据卷名1</span>
  <span class="token key atrule">dbdata</span><span class="token punctuation">:</span>  <span class="token comment"># 数据卷名2</span>
</code></pre><div class="line-numbers" aria-hidden="true"><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div></div></div></li><li><p>restart: 重启规则</p><div class="language-yaml line-numbers-mode" data-ext="yml"><pre class="language-yaml"><code><span class="token key atrule">restart</span><span class="token punctuation">:</span> <span class="token string">&quot;no&quot;</span>
<span class="token key atrule">restart</span><span class="token punctuation">:</span> always
<span class="token key atrule">restart</span><span class="token punctuation">:</span> on<span class="token punctuation">-</span>failure
<span class="token key atrule">restart</span><span class="token punctuation">:</span> unless<span class="token punctuation">-</span>stopped
</code></pre><div class="line-numbers" aria-hidden="true"><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div></div></div></li></ul></li><li><p>volumes: 声明或创建在多个服务中共同使用的数据卷对象</p></li><li><p>networks: 定义在多个服务中共同使用的网络对象</p><p><strong>P.S.</strong>: compose中多服务的相互访问：使用同一个网络，访问时直接使用 http://&lt;服务名&gt;:&lt;端口&gt;\` 即可</p></li><li><p>configs: 声明将在本服务中要使用的一些配置文件（多镜像共用的全局配置文件）</p></li><li><p>secrets: 声明将在本服务中要使用的一些秘钥、密码文件（密码等敏感信息，写入文件，用该字段导入）</p></li><li><p>x-***: 自定义配置。主要用于复用相同的配置（多镜像在compose file中使用相同的配置，用此进行抽象）</p></li></ul></li></ul><h3 id="案例" tabindex="-1"><a class="header-anchor" href="#案例" aria-hidden="true">#</a> 案例</h3><h4 id="flask项目环境搭建" tabindex="-1"><a class="header-anchor" href="#flask项目环境搭建" aria-hidden="true">#</a> flask项目环境搭建</h4><p>flask代码位于服务器 <em>/code/flaskapp</em> 文件夹内，并包含 <em>requirements.txt</em> 依赖包说明文件</p><ul><li><p>编写 dockerfile</p><div class="language-docker line-numbers-mode" data-ext="docker"><pre class="language-docker"><code><span class="token comment"># 获取python镜像 查看docker library官方python镜像，可选alpine（linux内核轻量版本）</span>
<span class="token instruction"><span class="token keyword">FROM</span> python:apline3.6</span>

<span class="token comment"># 服务端代码添加到镜像 ADD/COPY 本地文件夹到容器内指定文件夹</span>
<span class="token instruction"><span class="token keyword">COPY</span> ./flask-web-code /code</span>

<span class="token comment"># 安装服务端依赖环境</span>
<span class="token instruction"><span class="token keyword">WORKDIR</span> /code  # 容器内cd</span>
<span class="token instruction"><span class="token keyword">RUN</span> pip install -r requirements.txt</span>

<span class="token comment"># 运行 - 设置CMD 执行服务程序 推荐exec方式</span>
<span class="token instruction"><span class="token keyword">CMD</span> [<span class="token string">&quot;python&quot;</span>, <span class="token string">&quot;app.py&quot;</span>]</span>
</code></pre><div class="line-numbers" aria-hidden="true"><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div></div></div></li><li><p>(可选)构建镜像 <code>docker build . -t my-flask-img</code>（此处不进行，在 compose 加载 dockerfile 时也会自动构建）</p></li><li><p>编写 docker compose file <em>docker-compose.yaml</em></p><div class="language-yaml line-numbers-mode" data-ext="yml"><pre class="language-yaml"><code><span class="token key atrule">version</span><span class="token punctuation">:</span> <span class="token string">&quot;3.6&quot;</span>
<span class="token key atrule">service</span><span class="token punctuation">:</span>
    <span class="token comment"># flask服务</span>
    <span class="token key atrule">flask-web</span><span class="token punctuation">:</span>
        <span class="token key atrule">build</span><span class="token punctuation">:</span> .  <span class="token comment"># dockerfile位于当前文件夹</span>
        <span class="token key atrule">ports</span><span class="token punctuation">:</span>
            <span class="token punctuation">-</span> <span class="token string">&quot;5000:5000&quot;</span>
        <span class="token key atrule">container_name</span><span class="token punctuation">:</span> flask<span class="token punctuation">-</span>web  <span class="token comment"># 可选，指定运行后的容器名称</span>
        <span class="token key atrule">networks</span><span class="token punctuation">:</span>  <span class="token comment"># 可选，引用声明的网络，不指定默认创建一个桥接网络用于services内所有容器，实现容器间通信</span>
            <span class="token punctuation">-</span> web
    <span class="token comment"># redis服务</span>
    <span class="token key atrule">redis</span><span class="token punctuation">:</span>
        <span class="token key atrule">image</span><span class="token punctuation">:</span> redis <span class="token comment"># 该镜像已自己暴露6379</span>
        <span class="token comment"># 如需宿主机以外的服务访问，需要配置端口映射：ports</span>
        <span class="token comment"># 此处只需要flask服务访问，不做端口映射</span>
        <span class="token key atrule">container_name</span><span class="token punctuation">:</span> redis  <span class="token comment"># 可选，指定运行后的容器名称</span>
        <span class="token key atrule">networks</span><span class="token punctuation">:</span>  <span class="token comment"># 可选，引用声明的网络，不指定默认创建一个桥接网络用于services内所有容器，实现容器间通信</span>
            <span class="token punctuation">-</span> web
        <span class="token key atrule">volumes</span><span class="token punctuation">:</span>  <span class="token comment"># 可选。防止 compose down 导致的镜像数据卷重置</span>
            <span class="token punctuation">-</span> redis<span class="token punctuation">-</span>data<span class="token punctuation">:</span>/data  <span class="token comment"># 数据卷名: 路径 （路径通过inspect查看）</span>

<span class="token comment"># 可选 声明网络，供services引用，services内不指定默认创建一个桥接网络用于services内所有容器，实现容器间通信</span>
<span class="token key atrule">networks</span><span class="token punctuation">:</span>
    <span class="token key atrule">web</span><span class="token punctuation">:</span>  <span class="token comment"># 网络名</span>
        <span class="token key atrule">driver</span><span class="token punctuation">:</span> <span class="token string">&quot;bridge&quot;</span>

<span class="token comment"># 可选 - 为了避免 compose down 时的数据丢失，一般都会声明</span>
<span class="token key atrule">volumes</span><span class="token punctuation">:</span>
    <span class="token key atrule">redis-data</span><span class="token punctuation">:</span>  <span class="token comment"># 数据卷名称</span>
        <span class="token key atrule">driver</span><span class="token punctuation">:</span> <span class="token string">&quot;local&quot;</span>
</code></pre><div class="line-numbers" aria-hidden="true"><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div></div></div></li><li><p>检测当前文件夹内的 compose file 是否存在问题 <code>docker-compose config</code></p></li><li><p>启动当前文件夹内的 compose file 。更新 compose file 后，执行 <code>up</code> 会重新运行</p><ul><li>阻塞式启动 <code>docker-compose up</code></li><li>守护进程式启动 <code>docker-compose up -d</code></li></ul></li><li><p>停止</p><ul><li><code>docker-compose kill</code></li><li><code>docker-compose pause</code></li><li><code>docker-compose stop</code></li><li><code>docker-compose down</code> 会删除容器与网络，并影响数据卷（ compose 未声明数据卷情况下，若镜像声明了数据卷，会自动创建，<code>down</code> 后该数据卷不再使用，下次启动时新创建数据卷。可能引起数据丢失，一般是不再使用此 compose 时才使用）</li></ul></li></ul><h4 id="单宿主机的elk系统" tabindex="-1"><a class="header-anchor" href="#单宿主机的elk系统" aria-hidden="true">#</a> 单宿主机的ELK系统</h4><p>日志数据处理分析平台，ES，Logstash，Kibana。Logstash（运输日志，将日志通过管道传输到对应服务，端口5000）获取日志存储到ES（存储日志，存储Logstash传输内容，端口9200），Kibana（呈现，提供一个前端页面，端口5601）提供页面对ES数据进行查看与管理</p>`,17),h=n("li",null,[n("p",null,"注意点"),n("ul",null,[n("li",null,"ES，Logstash 多开提高吞吐量"),n("li",null,"Logstash暴露5000端口用于写入，并需连接9200端口的ES"),n("li",null,"ES需要暴露9200端口写入"),n("li",null,"Kibana需要暴露5601端口用于访问，并需要连接9200端口")])],-1),y={href:"https://www.docker.elastic.co/",target:"_blank",rel:"noopener noreferrer"},f=a(`<div class="macos language-bash line-numbers-mode" data-ext="sh"><pre class="language-bash"><code><span class="token comment"># 指定版本则使用此方式: elasticsearch:x.x.x</span>
<span class="token function">docker</span> pull docker.elastic.co/elasticsearch/elasticsearch:sha256-xxx
<span class="token function">docker</span> pull docker.elastic.co/kibana/kibana:sha256-xxx
<span class="token function">docker</span> pull docker.elastic.co/logstash/logstash-oss:sha256-xxx
</code></pre><div class="line-numbers" aria-hidden="true"><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div></div></div>`,1),N={start:"2"},E={href:"https://www.docker.elastic.co/",target:"_blank",rel:"noopener noreferrer"},_={href:"https://www.elastic.co/guide/en/elasticsearch/reference/6.2/docker.html",target:"_blank",rel:"noopener noreferrer"},O=a(`<div class="language-yaml line-numbers-mode" data-ext="yml"><pre class="language-yaml"><code><span class="token key atrule">version</span><span class="token punctuation">:</span> <span class="token string">&#39;2.2&#39;</span>
<span class="token key atrule">services</span><span class="token punctuation">:</span>
    <span class="token key atrule">elasticsearch</span><span class="token punctuation">:</span>
        <span class="token key atrule">image</span><span class="token punctuation">:</span> docker.elastic.co/elasticsearch/elasticsearch<span class="token punctuation">:</span>6.2.4
        <span class="token key atrule">container_name</span><span class="token punctuation">:</span> elasticsearch
        <span class="token key atrule">environment</span><span class="token punctuation">:</span>
            <span class="token punctuation">-</span> cluster.name=docker<span class="token punctuation">-</span>cluster  <span class="token comment"># 集群名，确保两个es在同一集群</span>
            <span class="token punctuation">-</span> bootstrap.memory_lock=true  <span class="token comment"># 内存锁，防止内存无限消耗</span>
            <span class="token punctuation">-</span> <span class="token string">&quot;ES_JAVA_OPTS=-Xms512m -Xmx512m&quot;</span>  <span class="token comment"># 内存最小与最大范围</span>
        <span class="token key atrule">ulimits</span><span class="token punctuation">:</span>  <span class="token comment"># 内存锁设置权限 - 与内存锁一起出现，不然会报错</span>
            <span class="token key atrule">memlock</span><span class="token punctuation">:</span>
                <span class="token key atrule">soft</span><span class="token punctuation">:</span> <span class="token number">-1</span>
                <span class="token key atrule">hard</span><span class="token punctuation">:</span> <span class="token number">-1</span>
        <span class="token key atrule">volumes</span><span class="token punctuation">:</span>  <span class="token comment"># 使用数据卷保证 down 后数据不会丢失</span>
            <span class="token punctuation">-</span> esdata1<span class="token punctuation">:</span>/usr/share/elasticsearch/data
        <span class="token key atrule">ports</span><span class="token punctuation">:</span>  <span class="token comment"># 端口映射只打开一个，两个都可以访问到</span>
            <span class="token punctuation">-</span> 9200<span class="token punctuation">:</span><span class="token number">9200</span>
        <span class="token key atrule">networks</span><span class="token punctuation">:</span>  <span class="token comment"># 设置同一个网络</span>
            <span class="token punctuation">-</span> esnet
    <span class="token key atrule">elasticsearch2</span><span class="token punctuation">:</span>
        <span class="token key atrule">image</span><span class="token punctuation">:</span> docker.elastic.co/elasticsearch/elasticsearch<span class="token punctuation">:</span>6.2.4
        <span class="token key atrule">container_name</span><span class="token punctuation">:</span> elasticsearch2
        <span class="token key atrule">environment</span><span class="token punctuation">:</span>
            <span class="token punctuation">-</span> cluster.name=docker<span class="token punctuation">-</span>cluster  <span class="token comment"># 集群名，确保两个es在同一集群</span>
            <span class="token punctuation">-</span> bootstrap.memory_lock=true
            <span class="token punctuation">-</span> <span class="token string">&quot;ES_JAVA_OPTS=-Xms512m -Xmx512m&quot;</span>
            <span class="token punctuation">-</span> <span class="token string">&quot;discovery.zen.ping.unicast.hosts=elasticsearch&quot;</span>  <span class="token comment"># 设置host与1的一致，以达成集群效果。此处为1的默认值</span>
        <span class="token key atrule">ulimits</span><span class="token punctuation">:</span>
            <span class="token key atrule">memlock</span><span class="token punctuation">:</span>
                <span class="token key atrule">soft</span><span class="token punctuation">:</span> <span class="token number">-1</span>
                <span class="token key atrule">hard</span><span class="token punctuation">:</span> <span class="token number">-1</span>
        <span class="token key atrule">volumes</span><span class="token punctuation">:</span>  <span class="token comment"># 使用数据卷保证 down 后数据不会丢失</span>
            <span class="token punctuation">-</span> esdata2<span class="token punctuation">:</span>/usr/share/elasticsearch/data
        <span class="token key atrule">networks</span><span class="token punctuation">:</span>
            <span class="token punctuation">-</span> esnet

<span class="token key atrule">volumes</span><span class="token punctuation">:</span>
    <span class="token key atrule">esdata1</span><span class="token punctuation">:</span>
        <span class="token key atrule">driver</span><span class="token punctuation">:</span> local
    <span class="token key atrule">esdata2</span><span class="token punctuation">:</span>
        <span class="token key atrule">driver</span><span class="token punctuation">:</span> local

<span class="token key atrule">networks</span><span class="token punctuation">:</span>
    <span class="token key atrule">esnet</span><span class="token punctuation">:</span>
</code></pre><div class="line-numbers" aria-hidden="true"><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div></div></div>`,1),x=a(`<ol start="3"><li>测试ES服务</li></ol><div class="macos language-bash line-numbers-mode" data-ext="sh"><pre class="language-bash"><code><span class="token comment"># 启动 - 失败会自动重试</span>
<span class="token function">docker-compose</span> up <span class="token parameter variable">-d</span>

<span class="token comment"># 查看是否运行成功</span>
<span class="token function">docker</span> <span class="token function">ps</span> <span class="token parameter variable">-a</span>

<span class="token comment"># 查看compose日志 需在 compose file 目录中执行</span>
<span class="token function">docker-compose</span> logs  <span class="token comment"># 可以查看启动过程中可能出现的异常</span>

<span class="token comment"># 测试请求ES</span>
<span class="token function">curl</span> <span class="token number">127.0</span>.0.1:9200
</code></pre><div class="line-numbers" aria-hidden="true"><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div></div></div><p><strong>P.S.</strong>: 可能出现的问题</p>`,3),q=n("p",null,[n("em",null,"max virtual memory areas vm.max_map_count [65536] is too low, increase to at least [262144]")],-1),I={href:"https://www.elastic.co/guide/en/elasticsearch/reference/6.2/docker.html",target:"_blank",rel:"noopener noreferrer"},T=a(`<div class="language-systemd line-numbers-mode" data-ext="systemd"><pre class="language-systemd"><code><span class="token comment"># linux /etc/sysctl.conf</span>
sysctl -w vm.max_map_count<span class="token punctuation">=</span><span class="token value attr-value">262144</span>

<span class="token comment"># mac</span>
sysctl -w vm.max_map_count<span class="token punctuation">=</span><span class="token value attr-value">262144</span>
</code></pre><div class="line-numbers" aria-hidden="true"><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div></div></div>`,1),w={start:"4"},A={href:"https://www.elastic.co/guide/en/logstash/6.2/docker-config.html",target:"_blank",rel:"noopener noreferrer"},S=n("code",null,"http://elasticsearch:9200",-1),R=a(`<li><ol start="5"><li>compose file 中配置 Logstash 服务。完成后使用 <code>docker-compose config</code> 检测完成后。使用 <code>dicker-compose up -d</code> 启动</li></ol><div class="language-yaml line-numbers-mode" data-ext="yml"><pre class="language-yaml"><code><span class="token punctuation">...</span>重复内容省略<span class="token punctuation">...</span>

<span class="token key atrule">services</span><span class="token punctuation">:</span>
    <span class="token punctuation">...</span>重复内容省略<span class="token punctuation">...</span>

    <span class="token key atrule">logstash</span><span class="token punctuation">:</span>
        <span class="token key atrule">image</span><span class="token punctuation">:</span> docker.elastic.co/logstash/logstash<span class="token punctuation">:</span>6.2.4
        <span class="token key atrule">container_name</span><span class="token punctuation">:</span> logstash
        <span class="token key atrule">environment</span><span class="token punctuation">:</span>
            <span class="token punctuation">-</span> <span class="token string">&quot;LS_JAVA_OPTS=-Xms256m -Xmx256m&quot;</span>  <span class="token comment"># 设置内存使用量</span>
        <span class="token key atrule">networks</span><span class="token punctuation">:</span>
            <span class="token punctuation">-</span> esnet  <span class="token comment"># 与es使用同一网络以保证可以相互访问</span>
        <span class="token key atrule">depends_on</span><span class="token punctuation">:</span>  <span class="token comment"># 保证es服务启动后再启动该服务</span>
            <span class="token punctuation">-</span> elasticsearch
            <span class="token punctuation">-</span> elasticsearch2
<span class="token punctuation">...</span>重复内容省略<span class="token punctuation">...</span>
</code></pre><div class="line-numbers" aria-hidden="true"><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div></div></div></li>`,1),P={start:"6"},D={href:"https://www.elastic.co/guide/en/kibana/6.2/docker.html#docker-defaults",target:"_blank",rel:"noopener noreferrer"},C=n("code",null,"http://elasticsearch:9200",-1),M=a(`<li><ol start="7"><li>compose file 中配置 Kibana 服务</li></ol><div class="language-yaml line-numbers-mode" data-ext="yml"><pre class="language-yaml"><code><span class="token punctuation">...</span>重复内容省略<span class="token punctuation">...</span>

<span class="token key atrule">services</span><span class="token punctuation">:</span>
    <span class="token punctuation">...</span>重复内容省略<span class="token punctuation">...</span>

    <span class="token key atrule">kibana</span><span class="token punctuation">:</span>
        <span class="token key atrule">image</span><span class="token punctuation">:</span> docker.elastic.co/kibana/kibana<span class="token punctuation">:</span>6.2.4
        <span class="token key atrule">container_name</span><span class="token punctuation">:</span> kibana
        <span class="token key atrule">ports</span><span class="token punctuation">:</span>
            <span class="token punctuation">-</span> <span class="token string">&quot;5601:5601&quot;</span>  <span class="token comment"># 端口映射用于内部web服务在外部可进行启动</span>
        <span class="token key atrule">networks</span><span class="token punctuation">:</span>
            <span class="token punctuation">-</span> esnet  <span class="token comment"># 与es使用同一网络以保证可以相互访问</span>
        <span class="token key atrule">depends_on</span><span class="token punctuation">:</span>  <span class="token comment"># 保证es服务启动后再启动该服务</span>
            <span class="token punctuation">-</span> elasticsearch
            <span class="token punctuation">-</span> elasticsearch2

<span class="token punctuation">...</span>重复内容省略<span class="token punctuation">...</span>
</code></pre><div class="line-numbers" aria-hidden="true"><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div></div></div></li><li><ol start="8"><li>启动ELK</li></ol><div class="macos language-bash line-numbers-mode" data-ext="sh"><pre class="language-bash"><code><span class="token comment"># 检测配置文件是否有语法问题</span>
<span class="token function">docker-compose</span> config
<span class="token comment"># 启动</span>
<span class="token function">docker-compose</span> up <span class="token parameter variable">-d</span>
<span class="token comment"># 查看容器情况</span>
<span class="token function">docker</span> <span class="token function">ps</span> <span class="token parameter variable">-a</span>
<span class="token comment"># 查看日志</span>
<span class="token function">docker-compose</span> log
<span class="token comment"># 查看ELK是否正常</span>
<span class="token function">curl</span> <span class="token number">127.0</span>.0.1:9200  <span class="token comment"># 查看es</span>
<span class="token function">curl</span> <span class="token number">127.0</span>.0.1:5601  <span class="token comment"># 查看kibana，可通过浏览器访问前端页面</span>
</code></pre><div class="line-numbers" aria-hidden="true"><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div></div></div></li>`,2),L=a(`<p><strong>P.S.</strong> logstash集群配置</p><div class="language-yaml line-numbers-mode" data-ext="yml"><pre class="language-yaml"><code><span class="token punctuation">...</span>重复内容省略<span class="token punctuation">...</span>
    
<span class="token key atrule">services</span><span class="token punctuation">:</span>
    <span class="token punctuation">...</span>重复内容省略<span class="token punctuation">...</span>

    <span class="token key atrule">logstash2</span><span class="token punctuation">:</span>  <span class="token comment"># 更改服务名称防止重复</span>
        <span class="token key atrule">image</span><span class="token punctuation">:</span> docker.elastic.co/logstash/logstash<span class="token punctuation">:</span>6.2.4
        <span class="token key atrule">container_name</span><span class="token punctuation">:</span> logstash2  <span class="token comment"># 更改容器名称防止重复</span>
        <span class="token key atrule">environment</span><span class="token punctuation">:</span>
            <span class="token punctuation">-</span> <span class="token string">&quot;LS_JAVA_OPTS=-Xms256m -Xmx256m&quot;</span>
        <span class="token key atrule">networks</span><span class="token punctuation">:</span>
            <span class="token punctuation">-</span> esnet
        <span class="token key atrule">depends_on</span><span class="token punctuation">:</span>
            <span class="token punctuation">-</span> elasticsearch
            <span class="token punctuation">-</span> elasticsearch2

    <span class="token punctuation">...</span>重复内容省略<span class="token punctuation">...</span>
</code></pre><div class="line-numbers" aria-hidden="true"><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div></div></div><h4 id="多宿主机的elk系统" tabindex="-1"><a class="header-anchor" href="#多宿主机的elk系统" aria-hidden="true">#</a> 多宿主机的ELK系统</h4><blockquote><p>swarm: docker内置的集群管理工具，使用overlay网络，支持负载均衡</p></blockquote><p>此处已两台宿主机为例，通过 swarm 实现容器间通信</p>`,5),G=a(`<li><p>swarm的使用</p><ul><li><p>swarm 初始化。宿主机A 执行 <code>docker swarm init</code>，得到加入 swarm 命令</p><div class="macos language-bash line-numbers-mode" data-ext="sh"><pre class="language-bash"><code><span class="token function">docker</span> swarm <span class="token function">join</span> <span class="token parameter variable">--token</span> SWMTKN-1-******* <span class="token number">10.211</span>.55.7:2377
</code></pre><div class="line-numbers" aria-hidden="true"><div class="line-number"></div></div></div></li><li><p>宿主机A查看当前节点 <code>docker node ls</code>。宿主机A在初始化时已自动加入</p><div class="macos language-text line-numbers-mode" data-ext="text"><pre class="language-text"><code>ID          HOSTNAME        STATUS          AVAILABILITY           MANAGER STATUS(Leader表示主节点)       ENGINE VERSION
宿主机A的信息
</code></pre><div class="line-numbers" aria-hidden="true"><div class="line-number"></div><div class="line-number"></div></div></div></li><li><p>宿主机B加入。执行 swarm 初始化得到的命令 <code>docker swarm join --token SWMTKN-1-******* 10.211.55.7:2377</code></p></li><li><p>宿主机A查看当前节点 <code>docker node ls</code>。可查看到到两条数据</p></li><li><p>查看网络信息 <code>docker network ls</code>，可发现 <em>docker_gwbridge</em> 与 <em>ingress</em></p><div class="macos language-text line-numbers-mode" data-ext="text"><pre class="language-text"><code>ID      NAME                DRIVER      SCOPE
xxx     docker_gwbridge     bridge      local  # 用于容器访问外部网络
xxx     ingress             overlay     swarm  # 用于容器间/集群间通信
</code></pre><div class="line-numbers" aria-hidden="true"><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div></div></div></li></ul></li>`,1),U=n("p",null,"多宿主机compose 与 单宿主机compose 的不同",-1),K=a("<li><p>使用 swarm 部署跨主机服务，不支持dockerfile，只能使用image镜像。dockerfile构建镜像必须在 compose 外单独执行生成出可用镜像</p></li><li><p>一个服务可启动多个容器</p></li><li><p>compose file + docker stack/service (不使用单宿主机的 compose file + compose cli)</p></li><li><p>部分 compose 配置项在 使用 <code>stack</code> 在 swarm 中无效。如 <code>build</code> / <code>container_name</code> / <code>ulimits</code> / <code>depends_on</code> 等</p></li><li><p>使用 <code>docker stack deploy</code> 启动，而不是 <code>docker-compose up</code></p></li>",5),V=n("code",null,"deploy",-1),Y=n("code",null,"deploy",-1),H={href:"https://docs.docker.com/reference/compose-file/deploy/",target:"_blank",rel:"noopener noreferrer"},X=a(`<div class="language-yaml line-numbers-mode" data-ext="yml"><pre class="language-yaml"><code><span class="token key atrule">services</span><span class="token punctuation">:</span>
    <span class="token key atrule">frontend</span><span class="token punctuation">:</span>
        <span class="token key atrule">image</span><span class="token punctuation">:</span> example/webapp
        <span class="token key atrule">ports</span><span class="token punctuation">:</span>
            <span class="token punctuation">-</span> <span class="token string">&quot;8080:80&quot;</span>
        <span class="token key atrule">deploy</span><span class="token punctuation">:</span>
            <span class="token key atrule">mode</span><span class="token punctuation">:</span> replicated  <span class="token comment"># 默认mode就是replicated / global模式无法指定数量，而是在所有docker节点上都运行一个容器</span>
            <span class="token key atrule">replicas</span><span class="token punctuation">:</span> <span class="token number">2</span>  <span class="token comment"># 指定镜像启动多少个容器（所有docker节点上一共运行的容器数量）</span>
            <span class="token key atrule">endpoint_mode</span><span class="token punctuation">:</span> vip
</code></pre><div class="line-numbers" aria-hidden="true"><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div></div></div><ul><li><p><code>mode</code>: 支持 <code>replicated</code>(指定启动数量，swarm自行判断容器运行在哪台宿主机，想控制只能是用<code>constraints</code>) / <code>global</code>(每个宿主机启动1个)</p></li><li><p><code>placement</code>: 设置约束等</p><ul><li><code>constraints</code> 容器在满足约束的宿主机上运行，可使用<code>==</code> 或 <code>!=</code><ul><li>在指定 Node ID 的节点上运行容器 <code>node.id==2ivku8v2gvtg4</code></li><li>在 Node hostname 不是指定名称的节点上运行容器 <code>node.hostname!=node-2</code></li><li>在指定 Node role (manager-leader/worker-非leader) 的节点上运行容器 <code>node.role==manager</code></li><li>在指定 Node operating system 的节点上运行容器 <code>node.platform.os==windows</code></li><li>在指定 Node architecture 的节点上运行容器 <code>node.platform.arch==x86_64</code></li><li>在指定 User-defined node labels 的节点上运行容器 <code>node.labels.security==high</code></li><li>在指定 Docker Engine&#39;s labels 的节点上运行容器 <code>engine.labels.operatingsystem==ubuntu-24.04</code></li></ul></li></ul></li><li><p><code>resources</code>: 限制容器使用资源</p><div class="language-yaml line-numbers-mode" data-ext="yml"><pre class="language-yaml"><code><span class="token key atrule">services</span><span class="token punctuation">:</span>
  <span class="token key atrule">frontend</span><span class="token punctuation">:</span>
    <span class="token key atrule">image</span><span class="token punctuation">:</span> example/webapp
    <span class="token key atrule">deploy</span><span class="token punctuation">:</span>
      <span class="token key atrule">resources</span><span class="token punctuation">:</span>
        <span class="token key atrule">limits</span><span class="token punctuation">:</span>
          <span class="token key atrule">cpus</span><span class="token punctuation">:</span> <span class="token string">&#39;0.50&#39;</span>
          <span class="token key atrule">memory</span><span class="token punctuation">:</span> 50M
          <span class="token key atrule">pids</span><span class="token punctuation">:</span> <span class="token number">1</span>
      <span class="token key atrule">reservations</span><span class="token punctuation">:</span>
        <span class="token key atrule">cpus</span><span class="token punctuation">:</span> <span class="token string">&#39;0.25&#39;</span>
        <span class="token key atrule">memory</span><span class="token punctuation">:</span> 20M
</code></pre><div class="line-numbers" aria-hidden="true"><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div></div></div></li></ul>`,2),W=a(`<li><p>多宿主机ELK compose file 的编写</p><ul><li><p>deploy 配置</p><div class="language-yaml line-numbers-mode" data-ext="yml"><pre class="language-yaml"><code><span class="token key atrule">version</span><span class="token punctuation">:</span> <span class="token string">&#39;3.6&#39;</span>  <span class="token comment"># deploy 必须 3或以上</span>
<span class="token key atrule">services</span><span class="token punctuation">:</span>
  <span class="token key atrule">elasticsearch</span><span class="token punctuation">:</span>
    <span class="token punctuation">...</span>重复内容省略<span class="token punctuation">...</span>
    <span class="token key atrule">deploy</span><span class="token punctuation">:</span>
      <span class="token key atrule">placement</span><span class="token punctuation">:</span>
        <span class="token key atrule">constraints</span><span class="token punctuation">:</span>
          <span class="token punctuation">-</span> node.role == manager  <span class="token comment"># 让此容器在主节点运行</span>
  <span class="token key atrule">elasticsearch2</span><span class="token punctuation">:</span>
    <span class="token punctuation">...</span>重复内容省略<span class="token punctuation">...</span>
    <span class="token key atrule">deploy</span><span class="token punctuation">:</span>
      <span class="token key atrule">placement</span><span class="token punctuation">:</span>
        <span class="token key atrule">constraints</span><span class="token punctuation">:</span>
          <span class="token punctuation">-</span> node.role == worker  <span class="token comment"># 让此容器在从节点运行</span>
  <span class="token key atrule">logstash</span><span class="token punctuation">:</span>
    <span class="token punctuation">...</span>重复内容省略<span class="token punctuation">...</span>
    <span class="token key atrule">deploy</span><span class="token punctuation">:</span>
      <span class="token key atrule">replicas</span><span class="token punctuation">:</span> <span class="token number">2</span>  <span class="token comment"># 启动两台，mode默认为replicated，可省略</span>
  <span class="token key atrule">logstash2</span><span class="token punctuation">:</span>
    <span class="token punctuation">...</span>重复内容省略<span class="token punctuation">...</span>
    <span class="token key atrule">deploy</span><span class="token punctuation">:</span>
      <span class="token key atrule">replicas</span><span class="token punctuation">:</span> <span class="token number">2</span>  <span class="token comment"># 启动两台，mode默认为replicated，可省略</span>
  <span class="token key atrule">kibana</span><span class="token punctuation">:</span>
    <span class="token punctuation">...</span>重复内容省略<span class="token punctuation">...</span>
    <span class="token key atrule">deploy</span><span class="token punctuation">:</span>
      <span class="token key atrule">placement</span><span class="token punctuation">:</span>
        <span class="token key atrule">constraints</span><span class="token punctuation">:</span>  <span class="token comment"># web服务运行一个就够</span>
          <span class="token punctuation">-</span> node.role == manager  <span class="token comment"># 让此容器在主节点运行</span>
</code></pre><div class="line-numbers" aria-hidden="true"><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div></div></div></li><li><p>网络配置 - 将使用网络驱动修改为overlay</p><div class="language-yaml line-numbers-mode" data-ext="yml"><pre class="language-yaml"><code><span class="token key atrule">networks</span><span class="token punctuation">:</span>
  <span class="token key atrule">esnet</span><span class="token punctuation">:</span>
    <span class="token key atrule">driver</span><span class="token punctuation">:</span> <span class="token string">&quot;overlay&quot;</span>
</code></pre><div class="line-numbers" aria-hidden="true"><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div></div></div></li><li><p>移除 <code>ulimits</code> / <code>container_name</code> 等不支持参数</p><div class="language-yaml line-numbers-mode" data-ext="yml"><pre class="language-yaml"><code><span class="token key atrule">version</span><span class="token punctuation">:</span> <span class="token string">&#39;3.6&#39;</span>
<span class="token key atrule">services</span><span class="token punctuation">:</span>
  <span class="token key atrule">elasticsearch</span><span class="token punctuation">:</span>
    <span class="token key atrule">image</span><span class="token punctuation">:</span> docker.elastic.co/elasticsearch/elasticsearch<span class="token punctuation">:</span>6.2.4
    <span class="token comment"># container_name: elasticsearch  # 移除</span>
    <span class="token key atrule">environment</span><span class="token punctuation">:</span>
      <span class="token punctuation">-</span> cluster.name<span class="token punctuation">-</span>docker<span class="token punctuation">-</span>cluster
      <span class="token punctuation">-</span> bootstrap.memory_lock=false  <span class="token comment"># 由于ulimits无法使用，设置为false，保证容器正常启动</span>
      <span class="token punctuation">-</span> <span class="token string">&quot;ES_JAVA_OPTS=-Xms512m -Xmx512m&quot;</span>
    <span class="token comment"># ulimits:  # 移除</span>
    <span class="token comment">#   memlock:</span>
    <span class="token comment">#     soft: -1</span>
    <span class="token comment">#     hard: -1</span>
    <span class="token key atrule">volumes</span><span class="token punctuation">:</span>
      <span class="token punctuation">-</span> esdata1<span class="token punctuation">:</span>/usr/share/elasticsearch/data
    <span class="token key atrule">ports</span><span class="token punctuation">:</span>
      <span class="token punctuation">-</span> 9200<span class="token punctuation">:</span><span class="token number">9200</span>
    <span class="token key atrule">networks</span><span class="token punctuation">:</span>
      <span class="token punctuation">-</span> esnet
    <span class="token key atrule">deploy</span><span class="token punctuation">:</span>
      <span class="token key atrule">placement</span><span class="token punctuation">:</span>
        <span class="token key atrule">constraint</span><span class="token punctuation">:</span>
          node.role == manager
  <span class="token key atrule">elasticsearch2</span><span class="token punctuation">:</span>
    <span class="token key atrule">image</span><span class="token punctuation">:</span> docker.elastic.co/elasticsearch/elasticsearch<span class="token punctuation">:</span>6.2.4
    <span class="token comment"># container_name: elasticsearch2  # 移除</span>
    <span class="token key atrule">environment</span><span class="token punctuation">:</span>
      <span class="token punctuation">-</span> cluster.name=docker<span class="token punctuation">-</span>cluster
      <span class="token punctuation">-</span> bootstrap.memory_lock=false  <span class="token comment"># 由于ulimits无法使用，设置为false，保证容器正常启动</span>
      <span class="token punctuation">-</span> <span class="token string">&quot;ES_JAVA_OPTS=-Xms512m -Xmx512m&quot;</span>
      <span class="token punctuation">-</span> <span class="token string">&quot;discovery.zen.ping.unicast.hosts=elasticsearch&quot;</span>
    <span class="token comment"># ulimits:  # 移除</span>
    <span class="token comment">#   memlock:</span>
    <span class="token comment">#     soft: -1</span>
    <span class="token comment">#     hard: -1</span>
    <span class="token key atrule">volumes</span><span class="token punctuation">:</span>
      <span class="token punctuation">-</span> esdata2<span class="token punctuation">:</span>/usr/share/elasticsearch/data
    <span class="token key atrule">networks</span><span class="token punctuation">:</span>
      <span class="token punctuation">-</span> esnet
    <span class="token key atrule">deploy</span><span class="token punctuation">:</span>
      <span class="token key atrule">placement</span><span class="token punctuation">:</span>
        <span class="token key atrule">constraints</span><span class="token punctuation">:</span>
          <span class="token punctuation">-</span> node.role == worker
  <span class="token key atrule">logstash</span><span class="token punctuation">:</span>
    <span class="token key atrule">image</span><span class="token punctuation">:</span> docer.elastic.co/logstash/logstash<span class="token punctuation">:</span>6.2.4
    <span class="token key atrule">environment</span><span class="token punctuation">:</span>
      <span class="token punctuation">-</span> <span class="token string">&quot;LS_JAVA_OPTS=-Xms256m -Xmx256m&quot;</span>
    <span class="token comment"># container)name: logstash  # 移除</span>
    <span class="token key atrule">networks</span><span class="token punctuation">:</span>
      <span class="token punctuation">-</span> esnet
    <span class="token comment"># depends_on:  # 移除</span>
    <span class="token comment">#   - elasticsearch</span>
    <span class="token comment">#   - elasticsearch2</span>
    <span class="token key atrule">deploy</span><span class="token punctuation">:</span>
      <span class="token key atrule">replicas</span><span class="token punctuation">:</span> <span class="token number">2</span>
  <span class="token key atrule">logstash2</span><span class="token punctuation">:</span>
    <span class="token key atrule">image</span><span class="token punctuation">:</span> docer.elastic.co/logstash/logstash<span class="token punctuation">:</span>6.2.4
    <span class="token key atrule">environment</span><span class="token punctuation">:</span>
      <span class="token punctuation">-</span> <span class="token string">&quot;LS_JAVA_OPTS=-Xms256m -Xmx256m&quot;</span>
    <span class="token comment"># container)name: logstash2  # 移除</span>
    <span class="token key atrule">networks</span><span class="token punctuation">:</span>
      <span class="token punctuation">-</span> esnet
    <span class="token comment"># depends_on:  # 移除</span>
    <span class="token comment">#   - elasticsearch</span>
    <span class="token comment">#   - elasticsearch2</span>
    <span class="token key atrule">deploy</span><span class="token punctuation">:</span>
      <span class="token key atrule">replicas</span><span class="token punctuation">:</span> <span class="token number">2</span>
  <span class="token key atrule">kibana</span><span class="token punctuation">:</span>
    <span class="token key atrule">image</span><span class="token punctuation">:</span> docker.elastic.co/kibana/kibana<span class="token punctuation">:</span>6.2.4
    <span class="token comment"># container_name: kibana  # 移除</span>
    <span class="token key atrule">ports</span><span class="token punctuation">:</span>
      <span class="token punctuation">-</span> <span class="token string">&quot;5601:5601&quot;</span>
    <span class="token key atrule">networks</span><span class="token punctuation">:</span>
      <span class="token punctuation">-</span> esnet
    <span class="token comment"># depends_on:  # 移除</span>
    <span class="token comment">#   - elasticsearch</span>
    <span class="token comment">#   - elasticsearch2</span>

<span class="token key atrule">volumes</span><span class="token punctuation">:</span>
  <span class="token key atrule">esdata1</span><span class="token punctuation">:</span>
    <span class="token key atrule">driver</span><span class="token punctuation">:</span> local
  <span class="token key atrule">esdata2</span><span class="token punctuation">:</span>
    <span class="token key atrule">driver</span><span class="token punctuation">:</span> local

<span class="token key atrule">networks</span><span class="token punctuation">:</span>
  <span class="token key atrule">esnet</span><span class="token punctuation">:</span>
    <span class="token key atrule">driver</span><span class="token punctuation">:</span> 
</code></pre><div class="line-numbers" aria-hidden="true"><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div></div></div></li><li><p>检测语法异常 <code>docker-compose config</code></p></li></ul></li><li><p>启动 <code>docker stack deploy -c [compose file] [stack_name]</code>。使用<code>docker ps -a</code>查看运行效果</p><div class="macos language-bash line-numbers-mode" data-ext="sh"><pre class="language-bash"><code><span class="token function">docker</span> stack deploy <span class="token parameter variable">-c</span> docker-compose.yaml elk
</code></pre><div class="line-numbers" aria-hidden="true"><div class="line-number"></div></div></div></li><li><p>查看服务列表 <code>docker service ls</code></p></li><li><p>查看指定服务的日志 <code>docker service logs elasticsearch（服务名） [-f (与tail -f类似)]</code>。(由于容器反复重启失败，stack会自动移除并创建新容器，所以不能查看容器日志<code>docker logs</code>，而是查看服务日志<code>docker service logs</code>)</p></li><li><p>删除stack <code>docker stack rm [stack_name]</code> 。容器会依次关闭并删除，需要一定时间</p></li><li><p>重启，先 <code>stack rm</code> 删除stack，再启动 <code>stack deploy -c</code> 并创建stackstackss</p></li><li><p>测试：swarm的端口映射，每个 docker node 的IP都可以访问到对应服务</p><ul><li>ES <code>curl 127.0.0.1:9200</code></li><li>kibana 浏览器访问 <em>IP:5601</em></li></ul></li>`,7),j=a(`<h2 id="python运行环境" tabindex="-1"><a class="header-anchor" href="#python运行环境" aria-hidden="true">#</a> Python运行环境</h2><h3 id="pycharm连接docker内的python环境" tabindex="-1"><a class="header-anchor" href="#pycharm连接docker内的python环境" aria-hidden="true">#</a> Pycharm连接docker内的python环境</h3><p>Pycharm通过配置远程docker服务，服务器2375端口连接docker服务（不是容器），在docker中获取镜像，创建python解释器容器</p><p>Pycharm配置sftp服务，将本地代码传到docker所在服务器，通过docker数据卷映射到容器</p><ul><li><p>docker服务器修改docker配置文件 <em>/etc/docker/daemon.json</em> （如果没有该文件则手动创建），供pycharm远程连接</p><div class="language-json line-numbers-mode" data-ext="json"><pre class="language-json"><code><span class="token punctuation">{</span>
  <span class="token property">&quot;hosts&quot;</span><span class="token operator">:</span> <span class="token punctuation">[</span>
    <span class="token string">&quot;tcp://0.0.0.0:2375&quot;</span>  <span class="token comment">// 在 hosts 中增加该行</span>
    <span class="token string">&quot;unix:///var/run/docker.sock&quot;</span>  <span class="token comment">// 本地连接（默认），如果 hosts 中没有则手动添加该行</span>
  <span class="token punctuation">]</span>
<span class="token punctuation">}</span>
</code></pre><div class="line-numbers" aria-hidden="true"><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div></div></div></li><li><p>重启 docker 使配置生效 <code>service docker restart</code></p></li><li><p>配置Pycharm添加远程docker容器内的解释器 <em>Preferences -&gt; Python Interpreter -&gt; add... -&gt; Docker -&gt; Server: New... -&gt; TCP socket</em> 填写<code>tcp://&lt;服务器IP&gt;:2375</code></p></li></ul>`,5);function F(z,B){const e=i("ExternalLinkIcon");return c(),o("div",null,[m,n("p",null,[s("官方镜像的dockerfile地址 "),n("a",k,[s("https://github.com/docker-library/docs/"),l(e)]),s("，点击任意仓库文件夹后，打开README中Dockerfile超链接即可查看")]),v,n("p",null,[s("dockerfile 命令"),n("a",b,[s("官方文档"),l(e)])]),g,n("ul",null,[h,n("li",null,[n("ol",null,[n("li",null,[s("获取镜像 在"),n("a",y,[s("es官网"),l(e)]),s("点击复制按钮，复制拉取 ES，Logstash，Kibana 镜像的命令")])]),f]),n("li",null,[n("ol",N,[n("li",null,[s("在"),n("a",E,[s("es官网"),l(e)]),s("点击打开按钮，查看运行es镜像的文档。此处已6.2版本为例，文档中的 "),n("a",_,[s("compose file"),l(e)]),s(" 可运行一个es集群")])]),O]),n("li",null,[x,n("ul",null,[n("li",null,[q,n("p",null,[s("根据"),n("a",I,[s("文档"),l(e)]),s("，需要修改系统配置")]),T])])]),n("li",null,[n("ol",w,[n("li",null,[s("查看Logstash的配置。此处以"),n("a",A,[s("官方文档6.2"),l(e)]),s("为例，确认配置 pipeline（日志的来源与去向）及 settings（Logstash配置项）是否需要修改。由于默认es请求地址"),S,s(" 与实际配置的内网访问要求一致(http://<服务名>:<端口>)，因此无需修改（其中x-pack相关配置需要付费使用，可进行异常监控与邮件通知等功能）")])])]),R,n("li",null,[n("ol",P,[n("li",null,[s("查看Kibana配置。确认"),n("a",D,[s("官方文档6.2"),l(e)]),s("中的默认配置是否需要修改。由于默认es请求地址"),C,s(" 与实际配置的内网访问要求一致(http://<服务名>:<端口>)，因此无需修改")])])]),M]),L,n("ul",null,[G,n("li",null,[U,n("ul",null,[K,n("li",null,[n("p",null,[s("compose 必须配置 "),V,s(" ，且需要版本 3 或以上。以下为"),Y,s("的常用子配置项，详见"),n("a",H,[s("官方文档"),l(e)])]),X])])]),W]),j])}const $=t(u,[["render",F],["__file","018.html.vue"]]);export{$ as default};
